'use strict';

var apiGenerator = require('./api-generator');

//Global variables
var fs = global.fs = global.fs || require('fs');
var shelljs = global.shelljs = global.shelljs || require('shelljs');
var config = fs.existsSync('../../config.json') ? JSON.parse(fs.readFileSync('../../config.json')) : {};
var components = config.components;
var glob = require('glob');
var curPath = '';
var decRegex = /Directive|Component/;
var apiColl = {};
var indexCollection = {};
var globalReference = {};
var typeAliasColl = [];
var curModuleName;
var typeMatcher = ['Enumeration', 'Interface', 'Class'];
var groupMatch = ['Classes', 'Enumerations', 'Interfaces'];
var pChild = [];
var h1 = '# ';
var h3 = '\n### ';
var finalMapper = {
    'Component': 'Components',
    'Directive': 'Directives'
};
var apiThead = '\n| Name | Description |\n|------|-------------|';
var isUpdated = false;

function generateAngularApi(path) {
    if (components) {
        curPath = path;
        var apiJson = JSON.parse(fs.readFileSync('./public/api/file.json'));
        var children = apiJson.children;
        preProcess(children);
        for (var childs of children) {
            curModuleName = getCurrentModule(childs);
            if (curModuleName.length && !apiColl[curModuleName]) {
                apiColl[curModuleName] = { Component: '', Directive: '' };
                indexCollection[curModuleName] = '';
            }
            if (childs.children) {
                for (var child of childs.children) {
                    if (child.children && child.decorators && decRegex.test(child.decorators[0].name)) {
                        pChild = [child];
                        processChild(pChild);
                    }
                }
            }
        }
        for (var api in apiColl) {
            var loc = '../../ej2-docs/src/' + api + '/';
            if (fs.existsSync(loc) && fs.existsSync('./ej2-docs/src/' + api)) {
                var files = glob.sync(loc + 'api-*.md', { silent: true, ignore: [loc + 'api-index.md'] });
                for (var i = 0; i < files.length; i++) {
                    shelljs.cp('-R', files[i], './ej2-docs/src/' + api);
                    var lname = files[i].slice(files[i].lastIndexOf('-') + 1, files[i].lastIndexOf('.'));
                    var name = lname[0].toUpperCase() + lname.substring(1);
                    indexCollection[api] += '\n* [Hide_' + name + '](' + api + '/api-' + lname + '.md)';
                }
            }
            var content = '';
            var coll = apiColl[api];
            for (var type in coll) {
                if (coll[type].length) {
                    content += '\n## ' + finalMapper[type] + '\n' + apiThead + coll[type] + '\n';
                }
            }
            if (content.length) {
                content = '# API\n' + content;
                generateFile(api, 'api', content, true, curPath);
                generateFile(api, 'api-index', '* [`API`](' + api + '/api.md)' + indexCollection[api], true, curPath);
            }
        }
        return isUpdated;
    }
}
exports.generateAngularApi = generateAngularApi;

function preProcess(children) {
    for (var childs of children) {
        var curName = getCurrentModule(childs);
        var cGroups = childs.groups;
        var glen;
        if (!globalReference[curName]) {
            globalReference[curName] = [];
        }
        if (cGroups && (glen = cGroups.length)) {
            for (var i = 0; i < glen; i++) {
                var groups = cGroups[i];
                var title = groups.title;
                if (title === 'Type aliases') {
                    typeAliasColl = typeAliasColl.concat(groups.children);
                } else if (!curName.length) {
                    continue;
                } else if (groupMatch.indexOf(title) !== -1) {
                    globalReference[curName] = globalReference[curName].concat(groups.children);
                }
            }
        }
    }

}

function getCurrentModule(child) {
    var baseName = child.name.replace(/"/g, '').split('/')[0];
    return components.indexOf(baseName) !== -1 ? baseName : '';
}

function generateFile(moduleName, fileName, content, prevChange, curPath) {
    var modulePath = curPath + moduleName;
    if (!fs.existsSync(modulePath)) {
        return;
    }
    isUpdated = true;
    fs.writeFile(modulePath + '/' + apiGenerator.convertToLower(fileName, prevChange) + '.md', content, 'utf8');
}

function processChild(child) {
    for (var curProp of child) {
        var name = curProp.name;
        var kindString = curProp.kindString;
        var decorator = curProp.decorators[0].name;
        if (typeMatcher.indexOf(kindString) !== -1 && curProp.flags.isExported &&
            createTypeReference(curProp, name, kindString, curModuleName, curPath)) {
            var lname = apiGenerator.convertToLower(name);
            var shortText = apiGenerator.getMessageText(curProp, true);
            var curText = apiGenerator.getTableText(shortText);
            if (curText.length) {
                apiColl[curModuleName][decorator] += '\n| [' + name + '](./' + lname + '.html)| ' + curText + '|';
            }
            indexCollection[curModuleName] += '\n* [Hide_' + name + '](' + curModuleName + '/' + lname + '.md)';
        }
    }
}

function createTypeReference(obj, propName, kind, curModuleName, curPath) {
    var canIncluded = false;
    var topMessage = apiGenerator.getMessageText(obj);
    var topComment = h1 + propName + '\n' + (topMessage.length ? '\n' + topMessage + '\n' : '');
    var contents = '';
    var method = '';
    var property = '';
    var events = '';
    var prop = obj.children || [];
    for (var curObj of prop) {
        var curComment;
        var isClass = kind === 'Class';
        var isExported = curObj.flags.isExported && !(curObj.flags.isPrivate || curObj.flags.isProtected);
        if (curObj.flags.isPublic || isExported) {
            var kString = curObj.kindString;
            if (kString === 'Method') {
                if(checkReference(curObj.inheritedFrom)){
                    continue;
                }
                curComment = apiGenerator.getMessageText(curObj.signatures[0]);
                if (curComment.length) {
                    var mOptions = apiGenerator.getMethodType(curObj, false, curModuleName);
                    if (mOptions.flag) {
                        var returns = '*Returns void*';
                        if(curObj.signatures[0].type) {
                            var actRet = apiGenerator.getType(curObj.signatures[0].type, false, curModuleName);
                            actRet = actRet.replace(/`/g,'*');
                            if(actRet) {
                            returns = 'Returns' + actRet;
                          }
                        }
                        method += h3 + '' + curObj.name + '\n\n' + curComment + '\n' + (mOptions.content || '') + '\n' + returns + '\n';
                    }
                }
            } else if (kString === 'Enumeration member') {
                contents += '\n* `' + curObj.name + '`';
            } else if (kString === 'Event' || kString === 'Property') {
                curComment = apiGenerator.getMessageText(curObj);
                var propType = apiGenerator.getPropertyWithType(curObj, false, curModuleName);
                if (curComment.length && propType.length) {
                    var temp = curObj.name + propType + '\n\n' + curComment;
                    if (isClass) {
                        if (kString === 'Property') {
                            property += h3 + temp + apiGenerator.getTagValue(curObj.comment,'default') + '\n';
                        } else {
                            events += h3 + temp + '\n';
                        }
                    } else {
                        property += h3 + temp + '\n';
                    }

                }
            }
        }
    }
    contents += apiGenerator.getClassContent([property, method, events]);
    if (contents.length) {
        canIncluded = true;
        generateFile(curModuleName, propName, topComment + contents, false, curPath);

    }

    return canIncluded;
}
exports.createTypeReference = createTypeReference;

function clearComponentFolder(path) {
    if (!components.length) {
        return;
    }
    for (var comp of components) {
        var folder = path + comp;
        if (fs.existsSync(folder)) {
            var file = glob.sync(folder + '/api*.md', { silent: true });
            for (var i = 0; i < file.length; i++) {
                fs.unlinkSync(file[i]);
            }
        }
    }

}

exports.clearComponentFolder = clearComponentFolder;

function checkReference(reference){
    if(reference) {
        var module = reference.name.split('.')[0];
        return  module === 'Base' || module === 'Component';
    }
}
exports.checkReference = checkReference;