'use strict';

//Global variables
var fs = global.fs = global.fs || require('fs');
var apicollection = {};
var indexCollection = {};
var common = global.config || require('../utils/common.js');
var config = common.config();
var extRef = {};
var reference = fs.existsSync('../ref-api.json') ? JSON.parse(fs.readFileSync('../ref-api.json')) : {};
var h1 = '# ';
var h3 = '\n### ';
var globalReference = {};
var funcString = 'Function';
var functions = {};
var functionReference = {};
var typeAliasColl = [];
var glob = require('glob');
var groupMatch = ['Classes', 'Enumerations', 'Interfaces'];
var tagText = {
    default: '\n\nDefaults to *'
};
var curPath = '';
var thead = '| Parameter | Type | Description |\n|------|------|-------------|\n';
var eventhead = '| Paramter Name | Type |\n|------|------|\n';
var apiThead = '\n| Name | Description |\n|------|-------------|';
var typeMatcher = ['Enumeration', 'Interface', 'Class', 'Function'];
var isBaseComponent = false;
var baseName = '';
var curModuleName;
var isUpdated = false;
var compBase = config.baseMapping || [];
var compName = '', compBaseApi = {};
var switchApi = config.switchApiLocation || {};
var switchApiNames = {};
function generateApi(path) {
    curPath = path;
    var apiJson = JSON.parse(fs.readFileSync('./public/api/file.json'));
    var children = apiJson.children;

    if (!config.components.length) {
        isBaseComponent = true;
        baseName = common.currentPackage.split('ej2-')[1];
    }
    preProcessChild(children);
    for (var i = 0; i < children.length; i++) {
        var curChild = children[i];
        curModuleName = getCurrentModuleName(curChild);
        if (curModuleName.length) {
            if (!apicollection[curModuleName]) {
                apicollection[curModuleName] = { Class: '', Enumeration: '', Interface: '', Function: '' };
                indexCollection[curModuleName] = '';
            }
            if (!functions[curModuleName]) {
                functions[curModuleName] = '';
            }
            processChildren(curChild.children || []);
        }
    }
    for (var func in functions) {
        if (functions[func].length) {
            compName = isBaseComponent ? 'Base Library' : (curModuleName.charAt(0).toUpperCase() +
                curModuleName.slice(1) + ' Component');
            apicollection[func][funcString] += '\n| [Static Functions]' +
                '(./api-staticFunctions.html)| Root static functions of ' + compName + '|';
            functions[func] = h1 + 'Static Functions\n\nRoot static functions of ' +
                compName + '\n\n' + functions[func];
            indexCollection[func] += '\n* [Hide_Static Functions](' +
                curModuleName + '/api-staticFunctions.md)';
            generateFile(func, 'staticFunctions', functions[func]);
        }
    }
    if (Object.keys(extRef).length !== 0 && fs.existsSync('./third-party/')) {
        fs.writeFile('./third-party/ref-api.json', JSON.stringify({ 'ref': extRef }), 'utf8');
    }
    if (switchApiNames) {
        var names = Object.keys(switchApiNames);
        for (var x = 0; x < names.length; x++) {
            for (var y = 0; y < switchApiNames[names[x]].length; y++) {
                var name = switchApiNames[names[x]][y];
                var apiName = convertToLower(name);
                indexCollection[names[x]] += '\n* [Hide_' + name + '](' + names[x] + '/' + apiName + '.md)';
            }
        }
    }
    for (var api in apicollection) {
        var content = '';
        var switchKeys = Object.keys(switchApi);
        if (switchKeys.indexOf(api) !== -1) {
            continue;
        }
        var collection = apicollection[api];
        for (var type in collection) {
            if (collection[type].length) {
                content += collection[type];
            }
        }
        if (content.length) {
            content = '# API\n' + '\n' + apiThead + content + '\n';
            generateFile(api, 'api', content, true);
            generateFile(api, 'api-index', '* [`API`](' + api + '/api.md)' + indexCollection[api], true);
        }
    }
    return isUpdated;
}

exports.generateApi = generateApi;

function processChildren(child) {
    for (var curProp of child) {
        var name = curProp.name;
        var kindString = curProp.kindString;
        if (typeMatcher.indexOf(kindString) !== -1 && curProp.flags.isExported &&
            !curProp.flags.isPrivate && createTypeReference(curProp, name, kindString)) {
            var lname = convertToLower(name);
            var shortText = getMessageText(curProp, true);
            var curText = getTableText(shortText);
            if (curText.length && name.indexOf('Model') === -1) {
                apicollection[curModuleName][kindString] += '\n| [' + name + '](./' + lname + '.html)| ' + curText + '|';
            }
            indexCollection[curModuleName] += '\n* [Hide_' + name + '](' + curModuleName + '/' + lname + '.md)';
        }
    }
}

function createTypeReference(obj, propName, kind) {
    var canIncluded = false;
    var topMessage = getMessageText(obj);
    var toplevelComment = h1 + propName + '\n' + (topMessage.length ? '\n' + topMessage + '\n' : '');
    var content = '';
    var methods = '';
    var properties = '';
    var events = '';
    var property = obj.children || [];
    for (var curObj of property) {
        var curComment;
        var isClass = kind === 'Class';
        var isExported = curObj.flags.isExported && !(curObj.flags.isPrivate);
        if ((curObj.flags.isPublic || isExported) && !curObj.flags.isProtected) {
            var kString = curObj.kindString;
            if (kString === 'Method') {
                for (var i = 0; i < curObj.signatures.length; i++) {
                    curComment = getMessageText(curObj.signatures[i]);
                    if (curComment.length) {
                        curObj.signNo = i;
                        var mOptions = getMethodType(curObj);
                        if (mOptions.flag) {
                            var ret = 'Returns *void*';
                            if (curObj.signatures[i].type) {
                                var actRet = getType(curObj.signatures[i].type);
                                actRet = actRet.replace(/`/g, '*');
                                if (actRet) {
                                    ret = 'Returns' + actRet;
                                }
                            }
                            methods += h3 + '' + curObj.name + '\n\n' + curComment + '\n' + (mOptions.content || '') + '\n' + ret + '\n';
                        }
                    }
                }
            } else if (kString === 'Enumeration member') {
                content += '\n* `' + curObj.name + '`';
            } else if (kString === 'Event' || kString === 'Property') {
                curComment = getMessageText(curObj);
                var propType = getPropertyWithType(curObj);
                if (curComment.length && propType.length) {
                    var temp = curObj.name + propType + '\n\n' + curComment;
                    if (isClass) {
                        if (kString === 'Property') {
                            properties += h3 + temp + getTagValue(curObj.comment, 'default') + '\n';
                        } else {
                            events += h3 + temp + '\n';
                        }
                    } else {
                        properties += h3 + temp + '\n';
                    }

                }
            } else if (kString === 'Accessor') {
                var acComment = getMessageText(curObj.getSignature[0]);
                var acType = getPropertyWithType(curObj.getSignature[0]);
                if (acComment.length && acType.length) {
                    properties += h3 + curObj.name + acType + '\n\n' + acComment + '\n';
                }
            }

        }
    }
    if (kind === 'Function' && functionReference[curModuleName].indexOf(obj.id) !== -1) {
        if (obj.flags.isExported && !obj.flags.isPrivate) {
            var fComment = getMessageText(obj.signatures[0]);
            if (fComment.length) {
                var fOptions = getMethodType(obj);
                if (fOptions.flag) {
                    var rtn = 'Returns *void*';
                    if (obj.signatures[0].type) {
                        var actRtn = getType(obj.signatures[0].type);
                        actRtn = actRtn.replace(/`/g, '*');
                        if (actRtn) {
                            rtn = 'Returns' + actRtn;
                        }
                    }
                    functions[curModuleName] += '## ' + obj.name + '\n\n' +
                        fComment + '\n' + (fOptions.content || '') + '\n' + rtn + '\n\n';
                }
            }
        }
    }
    content += getClassContent([properties, methods, events]);
    if (content.length) {
        if (compBase.indexOf(curModuleName) !== -1) {
            compBaseApi[propName] = toplevelComment + content;
        }
        canIncluded = true;
        generateFile(curModuleName, propName, toplevelComment + content);

    }

    return canIncluded;
}

function getPropertyWithType(obj, flag, curName) {
    var rejectList = ['element', 'constructor'];
    var name = obj.name;
    var type;
    if (!flag && rejectList.indexOf(name) !== -1) {
        return '';
    }
    type = getType(obj.type, obj.kindString === 'Event', curName);
    return type || '';
}
exports.getPropertyWithType = getPropertyWithType;
function getMethodType(mObj, excludeMsg, curName) {
    var ret = { flag: true, content: '' };
    var curObj = mObj.signatures[mObj.signNo || 0] || {};
    var typeCollection = [];
    var tbody = '';
    var params = curObj.parameters;
    if (params && params.length) {
        for (var cur of params) {
            var message = getMessageText(cur);
            var type = getPropertyWithType(cur, true, curName);
            if (type.length && (excludeMsg || message.length)) {
                var name = cur.name;
                if (cur.flags && cur.flags.isOptional) {
                    name += ' (*optional*)';
                }
                typeCollection.push(name);
                tbody += '| ' + name + ' | ' + type + (!excludeMsg ? (' | ' + getTableText(message)) : '') + ' |\n';
            }
        }
        if (typeCollection.length === params.length) {
            ret.flag = true;
            ret.content = '\n' + (excludeMsg ? eventhead : thead) + tbody;
        }
    }
    return ret;
}
exports.getMethodType = getMethodType;
function getMessageText(msgObject, shortText) {
    if (!msgObject.comment) {
        return '';
    }
    var msgText = (msgObject.comment.shortText || '') +
        ((msgObject.comment.shortText && msgObject.comment.text) ?
            ('\n' + msgObject.comment.text) : (msgObject.comment.text || ''));
    var ret = msgText;
    var sampleIndex = msgText.indexOf('```');
    if (sampleIndex !== -1) {
        ret = msgText.substr(0, sampleIndex - 1);
        if (!shortText) {
            ret = msgText;
        }
    }
    return ret;

}
exports.getMessageText = getMessageText;
function getTagValue(cur, key) {
    var tags = cur.tags;
    if (cur.tags) {
        for (var i = 0, len = tags.length; i < len; i++) {
            var tag = tags[i];
            if (tag.tag === key) {
                var text = tag.text.replace(/\n/g, '');
                if (!text) {
                    return '';
                }
                return tagText[key] + text + '*';
            }
        }
    }
    return '';
}
exports.getTagValue = getTagValue;
function processUnionObject(obj, curName) {
    var types = obj.types;
    var typeString = [];
    for (var k = 0; k < types.length; k++) {
        var name = getType(types[k], false, curName);
        if (name) {
            typeString.push(name);
        }
    }
    return typeString.join(' &#124; ');
}

function getType(type, isEvent, curName) {
    var iType = '', isArray, decl, intType, id;
    var isUnion = false;
    if (!type) {
        return '';
    }
    iType = type.name || (type.elementType ? (type.elementType.name ? type.elementType.name : '') : '');
    intType = type.type;
    id = type.id;
    isArray = type.isArray || type.type === 'array';
    decl = type.declaration || (type.elementType ? (type.elementType.declaration ? type.elementType.declaration : '') : '');
    if (!iType) {
        if (intType === 'union') {
            isUnion = true;
            iType = processUnionObject(type, curName);
        } else if (decl) {
            if (isEvent) {
                return getMethodType(decl, true).content || '`Object`';
            } else {
                iType = '`Object`';
            }

        }
    } else if (iType === 'EmitType') {
        var typeArguments = type.typeArguments;
        if (typeArguments && typeArguments.length) {
            var etype = getType(typeArguments[0], false, curName);
            etype = etype.replace(/ /g, '');
            var hindex = etype.indexOf('[');
            var lindex = etype.indexOf(']');
            if (hindex !== -1) {
                if (hindex !== etype.lastIndexOf('[')) {
                    return '  `EmitType<`' + etype + '`>`';
                } else {
                    return ' [`EmitType<' + etype.substring(hindex + 2, lindex - 1) + '>' + etype.substring(lindex - 1);
                }
            } else {
                etype = etype.replace(/&#124;/g, '|');
                return '  `EmitType<' + etype.replace(/`/g, '') + '>`';
            }
        }
        return '  `EmitType`';
    } else if (id) {
        if (typeAliasColl.indexOf(id) !== -1) {
            if (!extRef.typealias) { extRef.typealias = []; }
            extRef.typealias = extRef.typealias.concat(iType);
            iType = 'string';
        } else if (globalReference[curModuleName].indexOf(id) !== -1) {
            if (!extRef[curModuleName]) { extRef[curModuleName] = []; }
            extRef[curModuleName] = extRef[curModuleName].concat(iType);
            iType = ' [`' + iType + '`](./' + convertToLower(iType) + '.html)';
        } else {
            for (var i = 0; i < config.components.length; i++) {
                var curText = config.components[i];
                if (curText !== curModuleName && compBase) {
                    if (compBase.indexOf(curText) !== -1 && globalReference[curText].indexOf(id) !== -1 && compBaseApi[iType]) {
                        var apName = convertToLower(iType);
                        generateFile(curModuleName, iType, compBaseApi[iType]);
                        if (!indexCollection[curModuleName]) {
                            indexCollection[curModuleName] = '';
                        }
                        indexCollection[curModuleName] += '\n* [Hide_' + iType + '](' + curModuleName + '/' + apName + '.md)';
                        iType = ' [`' + iType + '`](./' + apName + '.html)';
                    }
                } else if (curText !== curModuleName && globalReference[curText].indexOf(id) !== -1) {
                    var lowerText = convertToLower(iType);
                    iType = ' [`' + iType + '`]("../../"' + curText + '/api/' + lowerText + '.html)';
                }
            }
        }
    } else if (curName && reference.ref) {
        if (reference.ref[curName] && reference.ref[curName].indexOf(iType) !== -1) {
            iType = ' [`' + iType + '`](./' + convertToLower(iType) + '.html)';
        } else if (reference.ref.typealias && reference.ref.typealias.indexOf(iType) !== -1) {
            iType = 'string';
        }
    }
    if (!isUnion && iType && iType.indexOf('[') === -1) {
        iType = (iType.indexOf('`') === -1) ? (' `' + iType + '`') : (' ' + iType);
    }
    var bindex = iType.lastIndexOf('`');
    return (isArray ? iType.slice(0, bindex) + '[]' + iType.slice(bindex) : iType);
}
exports.getType = getType;
function generateFile(moduleName, fileName, content, prevChange) {
    var modulePath = curPath + moduleName;
    if (switchApi[moduleName]) {
        modulePath = curPath + switchApi[moduleName];
        if (!switchApiNames[switchApi[moduleName]]) {
            switchApiNames[switchApi[moduleName]] = [];
        }
        switchApiNames[switchApi[moduleName]] = switchApiNames[switchApi[moduleName]].concat(fileName);
    }
    if (!fs.existsSync(modulePath)) {
        return;
    }
    isUpdated = true;
    fs.writeFile(modulePath + '/' + convertToLower(fileName, prevChange) + '.md', content, 'utf8');
}

function convertToLower(text, prevChange) {
    return (prevChange ? '' : 'api-') + text.substr(0, 1).toLowerCase() + text.substr(1);
}
exports.convertToLower = convertToLower;

function getClassContent(parts, isInterface) {
    var match = ['Properties', 'Methods', 'Events'];
    var ret = '';
    var index = 1;
    for (var i = 0, len = parts.length; i < len; i++) {
        var curStr = parts[i];
        if (curStr.length) {
            ret += (isInterface ? '' : '\n' + (index === 1 ? '## ' : '## ') + match[i] + '\n') + curStr;
            index++;
        }
    }
    return ret;
}

exports.getClassContent = getClassContent;

function preProcessChild(childs) {
    for (var child of childs) {
        var curName = getCurrentModuleName(child);
        var groups = child.groups;
        var glen;
        if (!globalReference[curName]) {
            globalReference[curName] = [];
        }
        if (!functionReference[curName]) {
            functionReference[curName] = [];
        }
        if (groups && (glen = groups.length)) {
            for (var i = 0; i < glen; i++) {
                var group = groups[i];
                var title = group.title;
                if (title === 'Type aliases') {
                    typeAliasColl = typeAliasColl.concat(group.children);
                } else if (!curName.length) {
                    continue;
                } else if (groupMatch.indexOf(title) !== -1) {
                    globalReference[curName] = globalReference[curName].concat(group.children);
                } else if (title === 'Functions') {
                    functionReference[curName] = functionReference[curName].concat(group.children);
                }
            }
        }
    }

}

function getCurrentModuleName(mChild) {
    if (isBaseComponent) {
        return baseName;
    }
    var name = mChild.name.replace(/"/g, '').split('/')[0];
    var switchName = '';
    if (Object.keys(switchApi).length) {
        switchName = switchApi[name] || '';
    }
    return (config.components.indexOf(name) !== -1 ? name : config.components.indexOf(switchName) !== -1 ? switchName : '');
}

function getTableText(text) {
    return text.replace(/\n/g, '<br>');
}
exports.getTableText = getTableText;

function clearComponentFolder(path) {
    var components = config.components;
    if (!components.length) {
        components = [common.currentPackage.split('ej2-')[1]];
    }
    for (var comp of components) {
        var curFolder = path + comp;
        if (fs.existsSync(curFolder)) {
            var files = glob.sync(curFolder + '/api*.md', { silent: true });
            for (var i = 0; i < files.length; i++) {
                fs.unlinkSync(files[i]);
            }
        }
    }

}
exports.clearComponentFolder = clearComponentFolder;