'use strict';

var apiGenerator = require('./api-generator');
var angApiGenerator = require('./angular-api-generator');

//Global variables
var fs = global.fs || require('fs');
var shelljs = global.shelljs || require('shelljs');
var config = fs.existsSync('../../config.json') ? JSON.parse(fs.readFileSync('../../config.json')) : {};
var components = config.components;
var glob = require('glob');
var globalReference = [];
var typeAliasCol = [];
var dirRegex = /Directive|Component/i;
var compRegex = /Component/i;
var typeMatcher = ['Enumeration', 'Interface', 'Class'];
var groupMatch = ['Classes', 'Enumerations', 'Interfaces'];
var curPath = '';
var currModuleName = '';
var apiCollection = {};
var indexCollection = {};
var prChild = [];
var h1 = '# ';
var finalMapper = {
    'Component': 'Components',
    'Directive': 'Directives'
};
var apiThead = '\n| Name | Description |\n|------|-------------|';
var isUpdated = false;
var files = [];
var apiNames = [];

function generateReactApi(path) {
    if(components) {
        curPath = path;
        var apiJson =   JSON.parse(fs.readFileSync('./public/api/file.json'));
        var children = apiJson.children;
        for(var x = 0; x < components.length; x++) {
            if(!indexCollection[components[x]]) {
                indexCollection[components[x]] = '';
            }
            var loc = '../../ej2-docs/src/' + components[x] + '/';
            if (fs.existsSync(loc) && fs.existsSync('./ej2-docs/src/' + components[x])) {
                files = glob.sync(loc + 'api-*.md', { silent: true, ignore: [loc + 'api-index.md'] });
                for (var i = 0; i < files.length; i++) {
                    shelljs.cp('-R', files[i], './ej2-docs/src/' + components[x]);
                    var lname = files[i].slice(files[i].lastIndexOf('-') + 1, files[i].lastIndexOf('.'));
                    var name = lname[0].toUpperCase() + lname.substring(1);
                    indexCollection[components[x]] += '\n* [Hide_' + name + '](' + components[x] + '/api-' + lname + '.md)';
                }
            }
        }
        if(files.length) {
            for(var y = 0; y < files.length; y++) {
                apiNames = apiNames.concat(files[y].slice(files[y].indexOf('api-') + 4, files[y].indexOf('.md')));
            }
        }
        preProcess(children);
        for(var child of children) {
            currModuleName = getCurrentModuleName(child);
            if(currModuleName.length && !apiCollection[currModuleName]) {
                apiCollection[currModuleName] = { Component: '', Directive: ''};
            }
            if(child.children) {
                for(var childs of child.children) {
                    if(childs.children && dirRegex.test(child.name)) {
                        prChild = [childs];
                        processChildren(prChild);
                    }
                }
            }
        }
        for(var api in apiCollection) {
            var content = '';
            var collection = apiCollection[api];
            for (var type in collection) {
                if (collection[type].length) {
                    content += '\n## ' + finalMapper[type] + '\n' + apiThead + collection[type] + '\n';
                }
            }
            if (content.length) {
                content = '# API\n' + content;
                generateFile(api, 'api', content, true);
                generateFile(api, 'api-index', '* [`API`](' + api + '/api.md)' + indexCollection[api], true);
            }
        }
        return isUpdated;
    }
}
exports.generateReactApi = generateReactApi;

function preProcess(children) {
    for (var child of children) {
        var curName = getCurrentModuleName(child);
        var childGroups = child.groups;
        var groupLen;
        if(!globalReference[curName] && curName !== '') {
            globalReference[curName] = [];
        }
        if(childGroups && (groupLen = childGroups.length)) {
            for(var i = 0; i < groupLen; i++) {
                var groups = childGroups[i];
                var gTitle = groups.title;
                if (gTitle === 'Type aliases') {
                    typeAliasCol[curName] = typeAliasCol.concat(groups.children);
                } else if (groupMatch.indexOf(gTitle) !== -1) {
                    globalReference[curName] = globalReference[curName].concat(groups.children);
                }
            }
        }
    }
}

function getCurrentModuleName(children) {
    var bName = children.name.replace(/"/g, '').split('/')[0];
    return components.indexOf(bName) !== -1 ? bName : '';
}

function generateFile(moduleName, fileName, content, prevChange) {
    var modulePath = curPath + moduleName;
    if (!fs.existsSync(modulePath)) {
        return;
    }
    isUpdated = true;
    fs.writeFile(modulePath + '/' + apiGenerator.convertToLower(fileName, prevChange) + '.md', content, 'utf8');
}

function processChildren(children) {
    for(var curProp of children) {
        var name = curProp.name;
        var kindString = curProp.kindString;
        var decorator = compRegex.test(curProp.sources[0].fileName.match(dirRegex)[0]) ? 'Component' : 'Directive' ;
        if(decorator === 'Directive') {
            if(curProp.extendedTypes[0].typeArguments) {
                var typeArgs = curProp.extendedTypes[0].typeArguments[0].name;
                var lTypeArgs = apiGenerator.convertToLower(typeArgs, true);
                    if(apiNames.indexOf(lTypeArgs) !== -1) {
                        var apName = apiGenerator.convertToLower(typeArgs);
                        var currText = apiGenerator.getMessageText(curProp, true);
                        currText = apiGenerator.getTableText(currText);
                        if(currText.length){
                            apiCollection[currModuleName][decorator] += '\n| [' + 
                                curProp.name + '](./' + apName + '.html)| ' + currText + '|';
                            var apiFile = fs.readFileSync('ej2-docs/src/' + currModuleName + '/' + apName + '.md', 'utf8');
                            apiFile = h1 + curProp.name + '\n\n' + apiGenerator.getMessageText(curProp) + 
                                '\n\n' + apiFile.slice(apiFile.indexOf('##'));
                            fs.writeFileSync('./ej2-docs/src/' + currModuleName + '/' + 
                                apiGenerator.convertToLower(curProp.name) + '.md', apiFile, 'utf8');
                        }
                        indexCollection[currModuleName] += '\n* [Hide_' + curProp.name + '](' + currModuleName + '/' + apName + '.md)';
                    }
            }
        } else if(decorator === 'Component' && typeMatcher.indexOf(kindString) !== -1 && 
            curProp.flags.isExported && angApiGenerator.createTypeReference(curProp, name, kindString, currModuleName, curPath)) {
                var lname = apiGenerator.convertToLower(name);
                var shortText = apiGenerator.getMessageText(curProp, true);
                var curText = apiGenerator.getTableText(shortText);
                if(curText.length) {
                    apiCollection[currModuleName][decorator] += '\n| [' + name + '](./' + lname + '.html)| ' + curText + '|';
                }
                indexCollection[currModuleName] += '\n* [Hide_' + name + '](' + currModuleName + '/' + lname + '.md)';
        }
    }
}
