'use strict';

var gulp = global.gulp = global.gulp || require('gulp');
var common = global.config = global.config || require('../utils/common.js');
var fs = global.fs = global.fs || require('fs');
var path = global.path = global.path || require('path');
var shelljs = global.shelljs = global.shelljs || require('shelljs');
var cdn = require('./cdn.js');

var regexp = common.regexp;
var currentRepo = common.currentRepo;

var productionIgnore =
    `.npmrc
**/*.ts
**/*.tsx
**/*.log
!**/*.d.ts
api.**/
spec/
demo/
demos/
aot/
ej2-docs/
ej2-resources/
public/
.git/
archive/
.vscode/
coverage/
cireports/
tempFile
shelljs_*
.npmignore
.gitignore
config.json
api.json
*.docx
help.md
CHANGELOG.md
pipeline.cmd
system.config.js
gulpfile.js
test-report/
github-repo/
test-main.js
tsconfig.json
rollup.config.js
tsconfig-aot.json
node-modules/
karma.conf.js
Jenkinsfile
coverage.txt
yarn.lock
.spelling
umd-deploy/
third-party/
dist/ts/
branchPackage.tgz
dist/global/*.js
**/index-all.js` +
'\n!dist/global/' + common.currentPackage + '.min.js' +
'\ndist/' + common.currentPackage + '.umd.js';

var npmIgnore = productionIgnore +
    `
!dist/ts/**/*.ts`;

// Ship src at root 
function shipSrc(source, destination, ignore) {
    var glob = require('glob');
    var files = glob.sync(source, { silent: true, ignore: ignore });
    for (var i = 0; i < files.length; i++) {
        var file = files[i].split('src/')[1];
        var target = destination + file;
        if (!fs.existsSync(path.dirname(target))) {
            shelljs.mkdir('-p', path.dirname(target));
        }
        fs.writeFileSync(target, fs.readFileSync(files[i]));
    }
}
exports.shipSrc = shipSrc;

/**
 * Create npmignore at root
 */
gulp.task('npmignore', function () {
    return createNpmIgnore(currentRepo);
});

// npmignore override
function createNpmIgnore(currentRepo, isProduction) {
    if (currentRepo !== 'ej2-build-tasks') {
        var currentIgnore, ignorePath = './.npmignore';
        try {
            if (fs.statSync(ignorePath).isFile()) {
                currentIgnore = fs.readFileSync(ignorePath);
                fs.writeFileSync(ignorePath, '');
            }
        } catch (e) { }
        if (isProduction) {
            npmIgnore = productionIgnore;
        }
        npmIgnore = currentIgnore ? npmIgnore + '\n' + currentIgnore : npmIgnore;
        if (currentRepo !== 'ej2-base-library') {
            npmIgnore = npmIgnore +
                `
            e2e/`;
        }
        fs.writeFileSync(ignorePath, npmIgnore);
    }
}
exports.createNpmIgnore = createNpmIgnore;

/**
 * Publish npm packages
 */
gulp.task('publish', ['npmignore', 'dev-registry'], function (done) {
    var simpleGit = require('simple-git')();
    if (currentRepo === 'ej2-build-tasks') {
        shipSrc('./src/services/**/*', './');
    }
    simpleGit.log(function (err, log) {
        var logs = common.getCommitDetails(log);
        if ((RegExp(regexp.COMMIT_TYPES).test(logs.lastCommit) || currentRepo === 'ej2') &&
            !RegExp(regexp.CI_SKIP).test(logs.lastCommit) && process.env.BRANCH_NAME === common.stagingBranch) {
            shelljs.exec('npm version -f ' + logs.release + ' --no-git-tag-version --no-verify');
            shelljs.exec('npm publish --registry http:' + process.env.PRIVATE_DEV_REGISTRY, function (exitCode) {
                done();
                shellDone(exitCode);
            });
        } else {
            done();
        }
    });
});

function shellDone(exitCode) {
    if (exitCode !== 0) {
        process.exit(1);
    }
}
exports.shellDone = shellDone;

/**
 * Deploy umd files in ftp location
 */
gulp.task('umd-deploy', ['ship-dist'], function (done) {
    var currentPackage = common.currentPackage === 'ej2' ? '' : common.currentPackage;
    var location = common.isMasterBranch ? 'packages/production/' + currentPackage : 'packages/development/' + currentPackage;
    cdn.publish('./umd-deploy', false, location, done);
});

/**
 * ship dist files
 */
gulp.task('ship-dist', function () {
    var gzip = require('gulp-gzip');
    var shipSrc = ['dist{,/**}', '!./dist/ts{,/**}', 'styles/**/*.css', '!styles/resources/*.css'];
    if (common.currentPackage === 'ej2') {
        shipSrc.push('./*.css');
    }
    return gulp.src(shipSrc, { base: '.' })
        .pipe(gzip({ append: false }))
        .pipe(gulp.dest('./umd-deploy'));
});

gulp.task('ci-skip', function (done) {
    var simpleGit = require('simple-git')();
    simpleGit.log(function (err, log) {
        var logs = common.getCommitDetails(log),
            coverage = '',
            stagingBranch = common.stagingBranch;
        if ((RegExp(regexp.COMMIT_TYPES).test(logs.lastCommit) || currentRepo === 'ej2') &&
            !RegExp(regexp.CI_SKIP).test(logs.lastCommit) && process.env.BRANCH_NAME === stagingBranch) {
            var user = process.env.GITLAB_USER;
            var token = process.env.GITLAB_TOKEN;
            var origin = 'http://' + user + ':' + token + '@gitlab.syncfusion.com/essential-studio/' + common.currentRepo + '.git';
            shelljs.exec('git remote set-url origin ' + origin + ' && git pull origin ' + stagingBranch);
            if (fs.existsSync('./coverage')) {
                coverage = 'coverage.txt';
                fs.writeFileSync('./' + coverage, fs.readFileSync('./coverage/report.txt'));
            }
            if (fs.existsSync(path.resolve('./current-api.json'))) {
                let apipath = path.resolve('./api.json');
                let json = JSON.stringify(require(path.resolve('./current-api.json')), null, '\t');
                fs.writeFileSync(apipath, json, 'utf-8');
            }
            shelljs.exec('git add -f package.json api.json ' + coverage);
            shelljs.exec('git commit -m \"ci-skip(EJ2-000): Branch merged and package is published [ci skip]\" --no-verify');
            shelljs.exec('git branch -f ' + stagingBranch + ' HEAD && git checkout ' + stagingBranch, shellDone);
            shelljs.exec('git push -f --set-upstream origin ' + stagingBranch + ' --no-verify', { silent: true }, function (exitCode) {
                done();
                shellDone(exitCode);
            });
        } else {
            done();
        }
    });
});