'use strict';

// Node JS global scope
var fs = global.fs = global.fs || require('fs');
var gulp = global.gulp = global.gulp || require('gulp');
var common = global.config = global.config || require('../utils/common.js');
var runSequence = global.runSequence = global.runSequence || require('run-sequence');

var config = common.config();

function compileTSFiles(tsConfigs, gulpObj, done) {
    var ts = require('gulp-typescript');
    // Default typescript config
    var defaultConfig = {
        typescript: require('typescript')
    };

    var tsProject, tsResult;

    function refreshValue(flag) {
        // Create the typescript project
        tsProject = ts.createProject('tsconfig.json', Object.assign((flag ? { removeComments: false } : {}), defaultConfig, tsConfigs));
        // Get typescript result
        tsResult = gulp.src(gulpObj.src, { base: gulpObj.base })
            .pipe(ts(tsProject))
            .on('error', function (e) {
                done(e);
                process.exit(1);
            });
    }

    // Compile d.ts and minified files
    if (gulpObj.needDts) {
        refreshValue(true);
        tsResult.dts.pipe(gulp.dest(gulpObj.dest));
    }
    refreshValue();
    // Combine and uglify js files using webpack

    if (gulpObj.hasOwnProperty('combine')) {
        var webpackStream = require('webpack-stream');
        var webpack = require('webpack');
        tsResult.js.pipe(webpackStream({
            output: {
                filename: `${common.currentPackage}${gulpObj.combine ? '.umd.min.js' : '.umd.js'}`,
                libraryTarget: 'umd'
            },
            externals: (gulpObj.externals || []),
            plugins: gulpObj.combine ? [
                new webpack.optimize.UglifyJsPlugin()
            ] : [],
            devtool: gulpObj.combine ? '' : 'inline-source-map',
        })).pipe(gulp.dest(gulpObj.dest))
            .on('end', function () {
                done();
            });
    }
    // Compile normal js files without uglification
    else {
        tsResult.js.pipe(gulp.dest(gulpObj.dest))
            .on('end', function () {
                done();
            });

    }
}
exports.compileTSFiles = compileTSFiles;

/** 
 * Compile TypeScript to JS
 */
var isValidRepo = (common.currentRepo !== 'ej2' && common.currentRepo !== 'ej2-samples' && common.currentRepo !== 'ej2-react-samples');
var preScript = !isValidRepo ? [] : ['execute-generator'];
gulp.task('scripts', preScript, function (done) {
    var isRemote = process.env.GITLAB_TOKEN || global.isLocal;
    var gulpObj = {
        src: config.ts,
        dest: './',
        base: '.',
        needDts: isRemote ? true : false
    };
    if (isRemote && isValidRepo) {
        generateRootFiles('./src');
    }
    return compileTSFiles({}, gulpObj, done);
});

//builders  execution
gulp.task('execute-generator', function (done) {
    runSequence('create-model', 'typedoc', done);
});

// Create common root files 
function generateRootFiles(source) {
    var path = require('path');
    var files = fs.readdirSync(source);
    for (var i = 0; i < files.length; i++) {
        var pathObj = path.parse(files[i]);
        var file = path.join(source, files[i]);
        var stat = fs.lstatSync(file);
        if ((stat.isDirectory()) || (pathObj.name === 'index' && pathObj.ext === '.ts')) {
            var name = pathObj.name === 'index' ? pathObj.name : pathObj.name + '/index';
            var content = getCommentLine(pathObj.name) + 'export * from \'' + source + '/' + name + '\';';
            fs.writeFileSync('./' + pathObj.name + '.ts', content);
        }
    }
    return;
}
exports.generateRootFiles = generateRootFiles;

// Generate comment line
function getCommentLine(description) {
    return '/**\n' + ' * ' + description + '\n */\n';
}
exports.getCommentLine = getCommentLine;

/**
 * Bundle all module using webpack
 */
gulp.task('bundle', function (done) {
    // require files    
    var webpackUtil = require('../utils/webpack');
    var webpackConfig = require(fs.realpathSync('./webpack.config.js'));
    return webpackUtil.bundleWebpack(webpackConfig, done);
});

/** 
 * Generate Model definition file.
 */
gulp.task('create-model', function () {
    var modelGen = require('../generators/model.js');
    return gulp.src(config.createmodel)
        .pipe(modelGen());
});

/**
 * Compile default theme
 */
gulp.task('styles', function (done) {
    runSequence('default-theme', 'compile-styles', done);
});

/**
 * Compile all themes
 */
gulp.task('styles-all', function (done) {
    runSequence('all-themes', 'compile-styles', done);
});

/** 
 * Compile scss to css
 */
var isCompiled = true;
gulp.task('compile-styles', function () {
    var gutil = require('gulp-util');
    var sass = require('gulp-sass');
    var autoPrefixer = require('gulp-autoprefixer');
    return gulp.src(config.styles, { base: './' })
        .pipe(sass({
            outputStyle: 'expanded',
            includePaths: config.node_modules
        }).on('error', function (error) {
            isCompiled = false;
            gutil.log(new gutil.PluginError('sass', error.messageFormatted).toString());
            this.emit('end');
        }))
        .pipe(autoPrefixer({ browsers: ['last 2 versions', 'ie >= 11'] }))
        .pipe(gulp.dest('.'))
        .on('end', function () {
            if (!isCompiled) {
                process.exit(1);
            }
        });
});


/**
 * Generate default theme files
 */
gulp.task('default-theme', function () {
    var themes = require('../generators/themes.js');
    return themes.generateThemes([config.defaultTheme]);
});

/**
 * Generate all theme files
 */
gulp.task('all-themes', function () {
    var themes = require('../generators/themes.js');
    return themes.generateThemes(config.themes);
});

/**
 * detect duplicate codes
 */
gulp.task('dedupe', function () {
    var jscpd = require('gulp-jscpd');
    var source = config.dedupe;
    if (common.currentRepo === 'ej2-build-tasks') {
        source = ['./src/**/*.js', './spec/**/*.js', '!./src/third-party/shared/property-reader.js'];
    }
    return gulp.src(source)
        .pipe(jscpd({
            verbose: true
        }));
});

/**
 * Run build task.
 */
gulp.task('build', function (done) {
    runSequence('styles-all', 'scripts', 'typedoc', done);
});