'use strict';
var packJson;
var fs = global.fs = global.fs || require('fs');
var directiveTemplate = '\n    public directivekeys: { [key: string]: Object } = {{directiveValue}};';
var attrTemplate = '\n    private controlAttributes: string[] = {cattrs};';
var skipTemplate = '\n    private skipRefresh: string[] = {{skipattr}};';
var shelljs = global.shelljs = global.shelljs || require('shelljs');
/**
 * util functions
 */

function toInitCap(str) {
    return str.replace(/\w\S*/g, function (txt) { return txt.charAt(0).toUpperCase() + txt.substr(1); });
}

function toInitLower(str) {
    return str.replace(/\w\S*/g, function (txt) { return txt.charAt(0).toLowerCase() + txt.substr(1); });
}
/**
 * React source generator class
 */
class ReactSourceGen {

    constructor(config, packInfo, done) {
        this.allIndex = [];
        this.allComponents = [];
        this.hasInjected = false;
        packJson = packInfo;
        this.srcPath = './third-party/react/src/';
        this.render(config, done);
        return this;
    }

    render(config, done) {
        for (var comp of config.components) {
            var cnt = fs.readFileSync(__dirname + '/' + 'component-template').toString();
            var dirName = comp.directoryName || '';
            var retVal;
            var fileName = comp.baseClass.toLowerCase() + '.component';
            this.allIndex.push('export * from \'./' + dirName + '\';');
            retVal = this.generateComponent(cnt, comp, dirName);
            this.writeFile(this.srcPath + dirName + '/' + fileName+'.tsx', retVal.content);
            retVal.localIndex.push('export * from \'./'+fileName+'\';');
            this.writeFile(this.srcPath + dirName+ '/index.ts',  retVal.localIndex.join('\n').replace(/{{dir}}/g, ''));
        }
        if (this.hasInjected) {
            this.allIndex.push('export { Inject } from \'@syncfusion/ej2-react-base\';');
        }
        this.allIndex.push('export * from \'' + packJson.name + '\';');
        this.writeFile(this.srcPath + 'index.ts', this.allIndex.join('\n').replace(/{{dir}}/g, ''));
        done();
    }



    generateComponent(cnt, comp, directoryName) {
        var localIndex = [];
        var comment = '';
        var  customkeys = '';
        var hasInjected = false;
        var customAttributes = {};
        var dirObject = {};
        var dirkey = '';
        var preventRefresh = '';
        if (comp.reactComment) {
            comment = comp.reactComment.join('\n');
        }

        if (comp.dynamicModules) {
            this.hasInjected = true;
            hasInjected = true;
        }
        if (comp.controlAttributes) {
            customAttributes = this.generateInterface(comp.controlAttributes, comp.baseClass);
        }
        cnt = cnt.replace(/{{controlAttributes}}/g, customAttributes.iface || '');
        cnt = cnt.replace(/{{attributeInterface}}/g, customAttributes.iname ? ' & ' + customAttributes.iname : '');
        if (customAttributes.iKeys) {
            customkeys = attrTemplate.replace(/{cattrs}/g, customAttributes.iKeys);
        }
        cnt = cnt.replace(/{{tagName}}/g, comp.preferredTag || 'div'); 
        var childDecider = ''; 
        if(comp.preferredTag !== 'input'){
            childDecider =   ', this.props.children';
         }
        cnt = cnt.replace(/{{childDecider}}/g, childDecider);       
        cnt = cnt.replace(/{{attributemapper}}/g, customkeys);
        cnt = cnt.replace(/{{hasInjected}}/g, hasInjected);
        cnt = cnt.replace(/{{baseClass}}/g, comp.baseClass);
        cnt = cnt.replace(/{{componentComments}}/g, comment);
        cnt = cnt.replace(/{{packageName}}/g, packJson.name);
        if(comp.preventRefresh) {
           preventRefresh = skipTemplate.replace(/{{skipattr}}/g,
           JSON.stringify(comp.preventRefresh).replace(/\"/g,'\'').replace(/,/g,', '));
        }
        cnt = cnt.replace(/{{skipRefresh}}/g,preventRefresh);
        if (comp.tagDirective) {
            this.generateDirective(comp.tagDirective, dirObject, localIndex, directoryName);
        }
        if(Object.keys(dirObject).length){
            var dirVal = JSON.stringify(dirObject).replace(/\"/g,'\'').replace(/,/g,', ').replace(/:/g,': ');
            dirkey = directiveTemplate.replace(/{{directiveValue}}/g,dirVal);
        }
        cnt = cnt.replace(/{{directiveKeys}}/g, dirkey);
        return {content:cnt, localIndex:localIndex};
    }

    generateDirective(configCollection, dirObject, localMapper, dirName) {
        for (var config of configCollection) {
            var tagCnt = fs.readFileSync(__dirname + '/' + 'directive-template').toString();
            var comment = '';
            if (config.reactComment) {
                comment = config.reactComment.join('\n');
            }
            var fName = (config.fileName || config.propertyName.toLowerCase()) + '-directive';
            var directory = config.directoryName || dirName;
            tagCnt = tagCnt.replace(/{{className}}/g, config.baseClass);
            tagCnt = tagCnt.replace(/{{packageName}}/g, packJson.name);
            tagCnt = tagCnt.replace(/{{arrClassName}}/g, toInitCap(config.arrayDirectiveClassName));
            tagCnt = tagCnt.replace(/{{directiveName}}/g, toInitCap(config.directiveClassName));
            tagCnt = tagCnt.replace(/{{propName}}/g, config.propertyName);
            tagCnt = tagCnt.replace(/{{tagComment}}/g, comment);
            var arrDir = toInitLower(config.arrayDirectiveClassName);
            var dir = toInitLower(config.directiveClassName);
            tagCnt = tagCnt.replace(/{{ModuleName}}/g, dir);
            tagCnt = tagCnt.replace(/{{arrayModuleName}}/g, arrDir);
            this.writeFile(this.srcPath + directory + '/' + fName + '.tsx', tagCnt);
            localMapper.push('export * from \'./' + fName + '\';'); 
            if (config.tagDirective) {
                dirObject[arrDir] = {};
                dirObject[arrDir][dir] = {};
                this.generateDirective(config.tagDirective, dirObject[arrDir][dir], localMapper, dirName);
            } else {
                dirObject[arrDir] = dir;
            }
        }

    }
    generateInterface(attrs, className) {
        let ret = {};
        let keys = Object.keys(attrs);
        let iface = '';
        let localKeys = [];
        for (let key of keys) {
            iface += '    ' + key + '?: ' + attrs[key].replace(/"/g, '') + ';\n';
            localKeys.push('\'' + key + '\'');
        }
        ret.iname = className + 'HtmlAttributes';
        ret.iface = 'export interface ' + ret.iname + ' {\n' + iface + '}';
        ret.iKeys = '[' + localKeys.join(', ') + ']';
        return ret;
    }

    writeFile(path, content) {
        var arPath = path.split('/');
        arPath.pop();
        shelljs.mkdir('-p', arPath.join('/'));
        fs.writeFileSync(path, content, 'utf8');
    }
}

module.exports = function (config, packInfo, done) {
    return new ReactSourceGen(config, packInfo, done);
};