'use strict';

var fs = global.fs = global.fs || require('fs');
var shelljs = global.shelljs = global.shelljs || require('shelljs');

/**
 * override config.json  
 */
exports.config = function () {
    var localConfig = require('../../config.json');
    var rootConfig = require(fs.realpathSync('./config.json'));
    return Object.assign(localConfig, rootConfig);
};

/**
 * get current repository name 
 */
var currentRepo = shelljs.exec('git config --get remote.origin.url', { silent: true })
    .stdout.split('essential-studio/')[1].replace('.git', '').replace('/', '').trim();
exports.currentRepo = currentRepo;

/**
 * get current package name 
 */
var pack = fs.readFileSync('./package.json', 'utf8');
var json = JSON.parse(pack);
var currentPackage = function () {
    return json.name.replace('@syncfusion/', '');
};
exports.currentPackage = currentPackage();

var hostName = shelljs.exec('hostname', { silent: true }).stdout;
exports.hostName = hostName;
var isRemoteServer = hostName.indexOf('syncdesk') === -1;
exports.isRemoteServer = isRemoteServer;

/**
 * get current package version 
 */
var currentVersion = function () {
    return json.version;
};
exports.currentVersion = currentVersion();

/**
 * get regex templates  
 */
var regexp = {
    BUG: /^bug(\(([A-Za-z0-9]+[-][0-9]*)\))?\: /,
    CI_SKIP: /^ci-skip(\(([A-Za-z0-9]+[-][0-9]*)\))?\: /,
    COMMIT_TYPES: /^(bug|config|documentation|feature|sample|ci-skip)(\(([A-Za-z0-9]+[-][0-9]*)\))?\: (.*)$/,
};
exports.regexp = regexp;

/**
 * get last valid commit message and release version  
 */
exports.getCommitDetails = function (log) {
    var version = 'minor';
    var validCommit = log.latest.message,
        prevCommit = null,
        i = 0;
    while (checkCommitMessage(prevCommit, validCommit) && currentRepo !== 'ej2') {
        prevCommit = log.all[i - 1] ? log.all[i - 1].message : prevCommit;
        validCommit = log.all[i].message;
        i++;
    }
    console.log('Commit Message: ' + validCommit);
    if (RegExp(regexp.BUG).test(validCommit)) {
        version = 'patch';
    }
    var logs = {
        release: version,
        lastCommit: validCommit
    };
    return logs;
};

function checkCommitMessage(prevMessage, currentMessage) {
    return (!RegExp(regexp.COMMIT_TYPES).test(currentMessage) ||
        (RegExp('^Merge ').test(prevMessage) && RegExp(regexp.CI_SKIP).test(currentMessage)));
}

exports.stagingBranch = process.env.STAGING_BRANCH;

var isMasterBranch = process.env.BRANCH_NAME === 'master';
exports.isMasterBranch = isMasterBranch;

exports.checkout = function (prefix, product, done) {
    var user = process.env.GITLAB_USER;
    var token = process.env.GITLAB_TOKEN;
    if (user && token) {
        if (prefix === 'asp-core') {
            clone(user, token, done, 'ej2-' + prefix, product);
        }
        else {
            clone(user, token, done, 'ej2-' + prefix + '-template', product);
        }
    } else {
        const readline = require('readline');
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });
        rl.question('Git Lab UserName:', (userName) => {
            rl.question('Git Lab Password:', (pwd) => {
                rl.close();
                if (prefix === 'asp-core') {
                    clone(userName, pwd, done, 'ej2-' + prefix, product);
                }
                else {
                    clone(userName, pwd, done, 'ej2-' + prefix + '-template', product);
                }
            });
        });
    }
};

function clone(user, token, done, name, product) {
    var shelljs = global.shelljs = global.shelljs || require('shelljs');
    token = token.replace('@', '%40');
    var tempRepo = 'https://' + user + ':' + token + '@gitlab.syncfusion.com/essential-studio/' + name + '.git';
    shelljs.exec(
        'git clone ' + tempRepo + ' ./third-party/' + product, { silent: false },
        function () {
            console.log('Clone has been completed!');
            done();
        }
    );
}
exports.clone = clone;
exports.thridPartyConfigure = function (product, prefix) {
    var libInfo = JSON.parse(fs.readFileSync('./third-party/config.json').toString());
    var localConfig = JSON.parse(fs.readFileSync('./config.json').toString());
    var packInfo = JSON.parse(fs.readFileSync('./package.json').toString());
    var descriptionMapper = { angular: 'Angular', react: 'React' };
    var packPath = './third-party/' + product + '/package.json';
    var confPath = './third-party/' + product + '/config.json';
    var keywords = libInfo.keywords;

    if (product === 'react') {
        keywords = keywords.replace(/ng/g, 'react');
    }
    var packContent = fs.readFileSync(packPath).toString();
    var confContent = fs.readFileSync(confPath).toString();
    packContent = packContent.replace(/0.0.0/g, packInfo.version);
    packContent = packContent.replace(/{{description}}/g, packInfo.description + ' for ' + descriptionMapper[product]);
    packContent = packContent.replace(/{{reponame}}/g, 'ej2-' + prefix + '-' + libInfo.name.toLowerCase());
    packContent = packContent.replace(/{{dependentrepo}}/g, packInfo.name);
    packContent = packContent.replace(/{{keywords}}/g, '["' + keywords.split(',').join('","') + '"]');
    packContent = packContent.replace(/{{repo}}/g, JSON.stringify(libInfo.repository));
    fs.writeFileSync(packPath, packContent);
    var curRepoName = packInfo.name.split('/')[1];
    if (typeof localConfig.styleDependency[0] === 'object') {
        var result = [];
        for (var i = 0; i < localConfig.styleDependency.length; i++) {
            var key = Object.keys(localConfig.styleDependency[i])[0];
            result.push('{"' + key + '": ["' + curRepoName + '/' + key + '"]}');
        }
        confContent = confContent.replace(/{{styleDependency}}/g, result.join(', '));
    } else if (localConfig.styleDependency === 'none') {
        confContent = confContent.replace(/\[{{styleDependency}}\]/g, '"none"');
    } else {
        confContent = confContent.replace(/{{styleDependency}}/g, '"' + curRepoName + '"');
    }
    fs.writeFileSync(confPath, confContent);
};

exports.extend = extend;
function extend(copied, first, second, deep) {
    var result = copied || {};
    var length = arguments.length;
    if (deep) {
        length = length - 1;
    }
    var _loop_1 = function (i) {
        if (!arguments_1[i]) {
            return 'continue';
        }
        var obj1 = arguments_1[i];
        Object.keys(obj1).forEach(function (key) {
            var src = result[key];
            var copy = obj1[key];
            var clone;
            if (deep && isObject(copy)) {
                clone = isObject(src) ? src : {};
                result[key] = extend({}, clone, copy, true);
            }
            else {
                result[key] = copy;
            }
        });
    };
    var arguments_1 = arguments;
    for (var i = 1; i < length; i++) {
        _loop_1(i);
    }
    return result;
}

function isObject(obj) {
    var objCon = {};
    return (!isNullOrUndefined(obj) && obj.constructor === objCon.constructor);
}

 function isNullOrUndefined(value) {
    return value === undefined || value === null;
}