import { merge, formatUnit, isNullOrUndefined, classList } from '@syncfusion/ej2-base';
import { attributes, addClass, removeClass, createElement, prepend, closest, remove } from '@syncfusion/ej2-base';
import { Component, EventHandler, BaseEventArgs, Property, Complex, Event } from '@syncfusion/ej2-base';
import { NotifyPropertyChanges, INotifyPropertyChanged, ChildProperty, KeyboardEvents } from '@syncfusion/ej2-base';
import { KeyboardEventArgs, EmitType } from '@syncfusion/ej2-base';
import { Animation, AnimationOptions, Effect, rippleEffect, Touch, SwipeEventArgs } from '@syncfusion/ej2-base';
import { DataManager, Query } from '@syncfusion/ej2-data';
import { createCheckBox } from '@syncfusion/ej2-buttons';
import { ListBase, ListBaseOptions, SortOrder, getFieldValues, FieldsMapping } from '../common/list-base';
import { ListViewModel, FieldSettingsModel } from './list-view-model';
// Effect Configuration Effect[] =  [fromViewBackward,fromViewForward,toViewBackward,toviewForward];
const effectsConfig: { [key: string]: Effect[] } = {
    'None': [],
    'SlideLeft': ['SlideRightOut', 'SlideLeftOut', 'SlideLeftIn', 'SlideRightIn'],
    'SlideDown': ['SlideTopOut', 'SlideBottomOut', 'SlideBottomIn', 'SlideTopIn'],
    'Zoom': ['FadeOut', 'FadeZoomOut', 'FadeZoomIn', 'FadeIn'],
    'Fade': ['FadeOut', 'FadeOut', 'FadeIn', 'FadeIn']
};

const effectsRTLConfig: { [key: string]: Effect[] } = {
    'None': [],
    'SlideLeft': ['SlideLeftOut', 'SlideRightOut', 'SlideRightIn', 'SlideLeftIn'],
    'SlideDown': ['SlideBottomOut', 'SlideTopOut', 'SlideTopIn', 'SlideBottomIn'],
    'Zoom': ['FadeZoomOut', 'FadeOut', 'FadeIn', 'FadeZoomIn'],
    'Fade': ['FadeOut', 'FadeOut', 'FadeIn', 'FadeIn']
};

// don't use space in classnames.
const classNames: ClassNames = {
    root: 'e-listview',
    hover: 'e-hover',
    selected: 'e-active',
    focused: 'e-focused',
    parentItem: 'e-list-parent',
    listItem: 'e-list-item',
    listItemText: 'e-list-text',
    grpListItem: 'e-list-group-item',
    hasChild: 'e-has-child',
    view: 'e-view',
    header: 'e-list-header',
    headerText: 'e-headertext',
    text: 'e-text',
    disable: 'e-disabled',
    content: 'e-content',
    icon: 'e-icons',
    backIcon: 'e-icon-back',
    checkboxWrapper: 'e-checkbox-wrapper',
    checkbox: 'e-checkbox',
    checked: 'e-check',
    checkboxIcon: 'e-frame',
    checkboxRight: 'e-checkbox-right',
    checkboxLeft: 'e-checkbox-left'
};

export interface Fields {
    /**
     * ID attribute of specific list-item.
     */
    id?: string;
    /**
     * It is used to map the text value of list item from the dataSource.
     */
    text?: string;
}

export class FieldSettings extends ChildProperty<FieldSettings> {

    /**
     * ID attribute of specific list-item.
     */
    @Property('id')
    public id: string;
    /**
     * It is used to map the text value of list item from the dataSource.
     */
    @Property('text')
    public text: string;

    /**
     * This property used to check whether the list item is in checked state or not.
     */
    @Property('isChecked')
    public isChecked: string;
    /**
     * To check whether the visibility state of list item.
     */
    @Property('isVisible')
    public isVisible: string;
    /**
     * It is used to enable the list item
     */
    @Property('enabled')
    public enabled: string;
    /**
     * It is used to customize the icon to the list items dynamically.
     *  We can add specific image to the icons using iconCss property.
     */
    @Property('iconCss')
    public iconCss: string;
    /**
     * This property used for nested navigation of list-items.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/documentation/list-view/nested-list.html?lang=typescript here}
     *  to know more about this property with demo.
     */
    @Property('child')
    public child: string;
    /**
     * It is used to display `tooltip content of text` while hovering on list items.
     */
    @Property('tooltip')
    public tooltip: string;

    /**
     * It wraps the list view element into a group based on the value of groupBy property.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/documentation/list-view/grouping.html?lang=typescript here}
     *  to know more about this property with demo.
     */
    @Property('groupBy')
    public groupBy: string;

    /**
     * It is used to enable the sorting of list items to be ascending or descending.
     */
    @Property('text')
    public sortBy: string;

    /**
     * Defines the HTML attributes such as id, class, etc,. for the specific list item.
     */
    @Property('htmlAttributes')
    public htmlAttributes: string;
    /**
     * It is used to fetch a specified named table data while using serviceUrl of DataManager
     *  in dataSource property.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/documentation/data/getting-started.html?lang=typescript here}
     *  to know more about this property with demo.
     */
    @Property('tableName')
    public tableName: string;
}

/**
 * Animation configuration settings.
 */
export interface AnimationSettings {
    /**
     * It is used to specify the effect which is shown in sub list transform.
     */
    effect?: ListViewEffect;
    /**
     * It is used to specify the time duration of transform object.
     */
    duration?: number;
    /**
     * It is used to specify the easing effect applied while transform
     */
    easing?: string;
}

/**
 * ListView animation effects
 */
export type ListViewEffect = 'None' | 'SlideLeft' | 'SlideDown' | 'Zoom' | 'Fade';

/**
 * ListView check box positions
 */
export type checkBoxPosition = 'Left' | 'Right';


/**
 * Represents the EJ2 ListView control.
 * ```html
 * <div id="listview">
 * <ul>
 * <li>Favourite</li>
 * <li>Documents</li>
 * <li>Downloads</li>
 * </ul>
 * </div>
 * ```
 * ```typescript
 *   var lvObj = new ListView({});
 *   lvObj.appendTo("#listview");
 * ```
 */
@NotifyPropertyChanges
export class ListView extends Component<HTMLElement> implements INotifyPropertyChanged {

    private ulElement: HTMLElement;
    private selectedLI: HTMLElement;
    private curUL: HTMLElement;
    private curDSLevel: string[] = [];
    private curViewDS: { [key: string]: Object }[] = [];
    private curDSJSON: { [key: string]: Object };
    public localData: { [key: string]: Object }[];
    private liCollection: HTMLElement[];
    private headerEle: HTMLElement;
    private contentContainer: HTMLElement;
    private keyboardModule: KeyboardEvents;
    private touchModule: Touch;
    private keyConfigs: { [key: string]: string } = {
        moveDown: 'downarrow',
        moveUp: 'uparrow',
        back: 'backspace',
        home: 'home',
        select: 'enter',
        end: 'end',
        tab: 'tab',
        space: 'space'
    };

    private listBaseOption: ListBaseOptions;
    private animateOptions: AnimationOptions = {};
    private rippleFn: Function;
    private isNestedList: boolean = false;
    private currentLiElements: HTMLElement[] = [];
    private resetList: boolean = false;
    private selectedData: string[] | string = [];
    private selectedId: string[] = [];

    private aniObj: Animation = new Animation(this.animateOptions);
    /**
     * This cssClass property helps to use custom skinning option for ListView component,
     *  by adding the mentioned class name into root element of ListView.
     * @default ''
     */
    @Property()
    public cssClass: string;

    /**
     * Defines the HTML attributes such as id, class, etc., for the ListView.
     * @default {}
     */
    @Property({})
    public htmlAttributes: { [key: string]: string; };

    /**
     * It specifies enabled state of ListView component.
     * @default true
     */
    @Property(true)
    public enable: boolean;

    /**
     * It provides the data to render the ListView component which is mapped
     *  with the fields of ListView.
     * @default []
     */
    @Property([])
    public dataSource: { [key: string]: Object }[] | string[] | DataManager;

    /**
     * It is used to fetch the specific data from dataSource by using where, select key words.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/documentation/list-view/data-binding.html?lang=typescript#bind-to-remote-data here}
     *  to know more about this property with demo.
     * @default null
     */
    @Property()
    public query: Query;

    /**
     * It is used to map keys from the dataSource which extracts the appropriate data from the dataSource
     *  with specified mapped with the column fields to render the ListView.
     * @default ListBase.defaultMappedFields
     */
    @Complex<FieldSettingsModel>(ListBase.defaultMappedFields, FieldSettings)
    public fields: FieldSettingsModel;

    /**
     * It is used to apply the animation to sub list navigation of list items.
     * @default { effect: 'SlideLeft', duration: 400, easing: 'ease' }
     */
    @Property<AnimationSettings>({ effect: 'SlideLeft', duration: 400, easing: 'ease' })
    public animation: AnimationSettings;

    /**
     * It is used to enable the sorting of list items to be ascending or descending.
     * @default 'None'
     */
    @Property<SortOrder>('None')
    public sortOrder: SortOrder;

    /**
     * Using this property, we can show or hide the icon of list item.
     * @default false
     */
    @Property<boolean>(false)
    public showIcon: boolean;

    /**
     * Using this property, we can show or hide the `checkbox`.
     * @default false
     */
    @Property<boolean>(false)
    public showCheckBox: boolean;

    /**
     * It is used to set the position of check box in an item.
     * @default 'Left'
     */
    @Property<string>('Left')
    public checkBoxPosition: checkBoxPosition;

    /**
     * It is used to set the title of ListView component.
     * @default ""
     */
    @Property<string>('')
    public headerTitle: string;

    /**
     * Using this property, we can show or hide the header of ListView component.
     * @default false
     */
    @Property<boolean>(false)
    public showHeader: boolean;

    /**
     * It is used to set the height of the ListView component.
     * @default ''
     */
    @Property('')
    public height: number | string;

    /**
     * It sets the width to the ListView component.
     * @default ''
     */
    @Property('')
    public width: number | string;

    /**
     * The ListView supports to customize the content of each list items with the help of template property.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/documentation/list-view/customizing-templates.html?lang=typescript here}
     *  to know more about this property with demo.
     * @default null
     */
    @Property(null)
    public template: string;

    /**
     * The ListView has an option to custom design the group header title with the help of groupTemplate property.
     * Refer the documentation
     *  {@link http://ej2.syncfusion.com/15.4.23/documentation/list-view/customizing-templates.html?lang=typescript#group-template here}
     *  to know more about this property with demo.
     * @default null
     */
    @Property(null)
    public groupTemplate: string;

    /**
     * We can trigger the `select` event when we select the list item in the component.
     * @event
     */
    @Event()
    public select: EmitType<SelectEventArgs>;

    /**
     * We can trigger `actionBegin` event before every ListView action starts.
     * @event
     */
    @Event()
    public actionBegin: EmitType<Object>;

    /**
     * We can trigger `actionComplete` event for every ListView action success event
     *  with the dataSource parameter.
     * @event
     */
    @Event()
    public actionComplete: EmitType<Object>;

    /**
     * We can trigger `actionFailure` event for every ListView action failure event
     *  with the dataSource parameter.
     * @event
     */
    @Event()
    public actionFailure: EmitType<Object>;


    /**
     * Constructor for creating the widget
     */
    constructor(options?: ListViewModel, element?: string | HTMLElement) {
        super(options, <HTMLElement | string>element);
    }

    public onPropertyChanged(newProp: ListViewModel, oldProp: ListViewModel): void {
        for (let prop of Object.keys(newProp)) {
            switch (prop) {
                case 'htmlAttributes':
                    this.setHTMLAttribute();
                    break;
                case 'cssClass':
                    this.setCSSClass(oldProp.cssClass);
                    break;
                case 'enable':
                    this.setEnable();
                    break;
                case 'width':
                case 'height':
                    this.setSize();
                    break;
                case 'enableRtl':
                    this.setEnableRTL();
                    break;
                case 'fields':
                    this.listBaseOption.fields = (this.fields as ListViewModel & { properties: Object }).properties;
                    this.reRender();
                    break;
                case 'headerTitle':
                    if (!this.curDSLevel.length) {
                        this.header(this.headerTitle, false);
                    }
                    break;
                case 'showHeader':
                    {
                        this.header(this.headerTitle, false);
                    }
                    break;
                case 'showCheckBox':
                case 'checkBoxPosition':
                    this.setCheckbox();
                    break;
                case 'dataSource':
                    this.reRender();
                    break;
                case 'sortOrder':
                case 'showIcon':
                    this.listBaseOption.showIcon = this.showIcon;
                    this.curViewDS = this.getSubDS();
                    this.resetCurrentList();
                    break;
                default:
                    break;
            }
        }
    }

    // Model Changes
    private setHTMLAttribute(): void {
        if (Object.keys(this.htmlAttributes).length) {
            attributes(this.element, this.htmlAttributes);
        }
    }

    private setCSSClass(oldCSSClass?: string): void {
        if (this.cssClass) {
            addClass([this.element], this.cssClass.split(' '));
        }
        if (oldCSSClass) {
            removeClass([this.element], oldCSSClass.split(' '));
        }
    }

    private setSize(): void {
        this.element.style.height = formatUnit(this.height);
        this.element.style.width = formatUnit(this.width);
    }

    private setEnable(): void {
        this.enableElement(this.element, this.enable);
    }

    private setEnableRTL(): void {
        if (this.enableRtl) {
            this.element.classList.add('e-rtl');
        } else {
            this.element.classList.remove('e-rtl');
        }
    }

    private enableElement(element: HTMLElement, isEnabled?: boolean): void {
        if (isEnabled) {
            element.classList.remove(classNames.disable);
        } else {
            element.classList.add(classNames.disable);
        }
    }

    //Suport Component Functions
    private header(text?: string, showBack?: boolean): void {
        if (this.headerEle === undefined && this.showHeader) {
            this.headerEle = createElement('div', { className: classNames.header });
            let innerHeaderEle: HTMLElement = createElement('span', { className: classNames.headerText, innerHTML: this.headerTitle });
            let textEle: HTMLElement = createElement('div', { className: classNames.text, innerHTML: innerHeaderEle.outerHTML });
            let hedBackButton: HTMLElement = createElement('div', {
                className: classNames.icon + ' ' + classNames.backIcon + ' e-but-back',
                attrs: { style: 'display:none;' }
            });
            this.headerEle.appendChild(hedBackButton);
            this.headerEle.appendChild(textEle);
            this.element.classList.add('e-has-header');
            prepend([this.headerEle], this.element);
        } else if (this.headerEle) {
            if (this.showHeader) {
                this.headerEle.style.display = '';
                let textEle: Element = this.headerEle.querySelector('.' + classNames.headerText);
                let hedBackButton: Element = this.headerEle.querySelector('.' + classNames.backIcon);
                textEle.innerHTML = text;
                if (showBack === true) {
                    (hedBackButton as HTMLElement).style.display = '';
                } else {
                    (hedBackButton as HTMLElement).style.display = 'none';
                }
            } else {
                this.headerEle.style.display = 'none';
            }
        }
    }

    // Animation Related Functions
    private switchView(fromView: HTMLElement, toView: HTMLElement, reverse?: boolean): void {
        if (fromView && toView) {
            let fPos: string = fromView.style.position;
            let overflow: string = (this.element.style.overflow !== 'hidden') ? this.element.style.overflow : '';

            fromView.style.position = 'absolute';
            fromView.classList.add('e-view');
            let anim: Effect[];
            let duration: number = this.animation.duration;
            if (this.animation.effect) {
                anim = (this.enableRtl ? effectsRTLConfig[this.animation.effect] : effectsConfig[this.animation.effect]);
            } else {
                let slideLeft: string = 'SlideLeft';
                anim = effectsConfig[slideLeft];
                reverse = this.enableRtl;
                duration = 0;
            }
            this.element.style.overflow = 'hidden';
            this.aniObj.animate(fromView, {
                name: (reverse === true ? anim[0] : anim[1]),
                duration: duration,
                timingFunction: this.animation.easing,
                end: (model: AnimationOptions): void => {
                    fromView.style.display = 'none';
                    this.element.style.overflow = overflow;
                    fromView.style.position = fPos;
                    fromView.classList.remove('e-view');
                }
            });
            toView.style.display = '';
            this.aniObj.animate(toView, {
                name: (reverse === true ? anim[2] : anim[3]),
                duration: duration,
                timingFunction: this.animation.easing,
                end: (): void => {
                    this.trigger('actionComplete');
                }
            });
            this.curUL = toView;
        }
    }

    protected preRender(): void {
        this.listBaseOption = {
            template: this.template,
            groupTemplate: this.groupTemplate, expandCollapse: true, listClass: '',
            ariaAttributes: {
                itemRole: 'listitem', listRole: 'list', itemText: '',
                groupItemRole: 'group', wrapperRole: 'presentation'
            },
            fields: (this.fields as ListViewModel & { properties: Object }).properties, sortOrder: this.sortOrder, showIcon: this.showIcon,
            itemCreated: this.renderCheckbox.bind(this)
        };
    }

    private renderCheckbox(args: ItemCreatedArgs): void {
        if (this.showCheckBox && this.isValidLI(args.item) && !this.isNestedList) {
            if (args.item.classList.contains(classNames.hasChild)) {
                this.checkboxRevert();
            } else {
                let checkboxElement: HTMLElement;
                let fieldData: { [key: string]: Object };
                checkboxElement = <HTMLElement>createCheckBox(false, { checked: false, enableRtl: this.enableRtl });
                checkboxElement.setAttribute('role', 'checkbox');
                let frameElement: HTMLElement = checkboxElement.querySelector('.' + classNames.checkboxIcon);
                args.item.classList.add('e-checklist');
                args.item.firstElementChild.classList.add(classNames.checkbox);
                if (typeof (this.dataSource as string[])[0] !== 'string') {
                    fieldData = <{ [key: string]: Object }>getFieldValues(args.curData, this.listBaseOption.fields);
                    if (!this.resetList && <string>fieldData[this.listBaseOption.fields.isChecked]) {
                        this.checkItem(args, checkboxElement);
                    } else if (this.selectedData.indexOf(<string>fieldData[this.listBaseOption.fields.text]) !== -1 &&
                        this.selectedId.indexOf(<string>fieldData[this.listBaseOption.fields.id]) !== -1) {
                        this.checkItem(args, checkboxElement);
                    }
                } else if (typeof (this.dataSource as string[])[0] === 'string' && this.selectedData.indexOf(args.text) !== -1) {
                    this.checkItem(args, checkboxElement);
                }
                checkboxElement.setAttribute('aria-checked', frameElement.classList.contains(classNames.checked) ? 'true' : 'false');
                if (this.checkBoxPosition === 'Left') {
                    checkboxElement.classList.add(classNames.checkboxLeft);
                    args.item.firstElementChild.insertBefore(checkboxElement, args.item.firstElementChild.childNodes[0]);
                } else {
                    checkboxElement.classList.add(classNames.checkboxRight);
                    args.item.firstElementChild.appendChild(checkboxElement);
                }
                this.currentLiElements.push(args.item);
            }
        }
    }

    private checkItem(args: ItemCreatedArgs, checkboxElement: HTMLElement): void {
        args.item.classList.add(classNames.selected);
        checkboxElement.querySelector('.' + classNames.checkboxIcon).classList.add(classNames.checked);
        checkboxElement.setAttribute('aria-checked', 'true');
    }

    private checkboxRevert(): void {
        this.isNestedList = true;
        this.setProperties({ 'showCheckBox': false }, true);
        for (let i: number = 0; i < this.currentLiElements.length; i++) {
            if (this.currentLiElements[i].querySelector('.' + classNames.checkboxWrapper)) {
                this.currentLiElements[i].firstElementChild.classList.remove(classNames.checkbox);
                this.removeElement(this.currentLiElements[i].firstElementChild.firstElementChild);
            }
        }
    }

    private setCheckbox(): void {
        if (this.showCheckBox && !this.curUL.querySelector('.' + classNames.hasChild)) {
            let args: ItemCreatedArgs = {
                item: undefined, curData: undefined, dataSource: undefined, fields: undefined,
                options: undefined, text: ''
            };
            this.liCollection.forEach((element: HTMLElement) => {
                args.item = element;
                args.curData = this.getItemData(element);
                if (element.querySelector('.' + classNames.checkboxWrapper)) {
                    this.removeElement(element.querySelector('.' + classNames.checkboxWrapper));
                }
                this.renderCheckbox(args);
            });
        } else {
            this.liCollection.forEach((element: HTMLElement) => {
                element.firstElementChild.classList.remove(classNames.checkbox);
                if (element.querySelector('.' + classNames.checkboxWrapper)) {
                    this.removeElement(element.querySelector('.' + classNames.checkboxWrapper));
                }
            });
        }
    }
    private clickHandler(e: MouseEvent): void {
        let target: Element = <Element>e.target;
        let classList: DOMTokenList = target.classList;
        if (classList.contains(classNames.backIcon) || classList.contains(classNames.headerText)) {
            this.back();
        } else {
            let li: HTMLElement = <HTMLElement>closest(target.parentNode, '.' + classNames.listItem);
            if (li === null) { li = <HTMLElement>target; }
            if (this.enable && this.showCheckBox && this.isValidLI(li)) {
                this.setCheckboxLI(li, e);
            } else {
                this.setSelectLI(li, e);
            }
        }
    }

    private removeElement(element: HTMLElement | Element): HTMLElement | Element {
        return element && element.parentNode && element.parentNode.removeChild(element);
    }

    private hoverHandler(e: MouseEvent): void {
        let curLi: HTMLElement = <HTMLElement>closest((<Element>e.target).parentNode, '.' + classNames.listItem);
        this.setHoverLI(curLi);
    }

    private leaveHandler(e: MouseEvent): void {
        this.removeHover();
    };
    private homeKeyHandler(e: KeyboardEventArgs, end?: boolean): void {
        let li: Element[] = <NodeListOf<Element> & Element[]>this.curUL.querySelectorAll('.' + classNames.listItem);
        let focusedElement: Element = this.curUL.querySelector('.' + classNames.focused) ||
            this.curUL.querySelector('.' + classNames.selected);
        if (focusedElement) {
            focusedElement.classList.remove(classNames.focused);
            if (!this.showCheckBox) {
                focusedElement.classList.remove(classNames.selected);
            }
        }
        let index: number = !end ? 0 : li.length - 1;
        if (li[index].classList.contains(classNames.hasChild) || this.showCheckBox) {
            li[index].classList.add(classNames.focused);
        } else {
            this.setSelectLI(li[index], e);
        }
    }

    private arrowKeyHandler(e: KeyboardEventArgs, prev?: boolean): void {
        let siblingLI: Element;
        let li: Element;
        let hasChild: boolean = !isNullOrUndefined(this.curUL.querySelector('.' + classNames.hasChild)) ? true : false;
        if (hasChild || this.showCheckBox) {
            li = this.curUL.querySelector('.' + classNames.focused) || this.curUL.querySelector('.' + classNames.selected);
            siblingLI = ListBase.getSiblingLI(this.curUL.querySelectorAll('.' + classNames.listItem), li, prev);
            if (!isNullOrUndefined(siblingLI)) {
                if (li) {
                    li.classList.remove(classNames.focused);
                    if (!this.showCheckBox) {
                        li.classList.remove(classNames.selected);
                    }
                }
                if (siblingLI.classList.contains(classNames.hasChild) || this.showCheckBox) {
                    siblingLI.classList.add(classNames.focused);
                } else {
                    this.setSelectLI(siblingLI, e);
                }
            }
        } else {
            li = this.curUL.querySelector('.' + classNames.selected);
            siblingLI = ListBase.getSiblingLI(this.curUL.querySelectorAll('.' + classNames.listItem), li, prev);
            this.setSelectLI(siblingLI, e);
        }
    }
    private enterKeyHandler(e: KeyboardEventArgs): void {
        let hasChild: boolean = !isNullOrUndefined(this.curUL.querySelector('.' + classNames.hasChild)) ? true : false;
        let li: Element = this.curUL.querySelector('.' + classNames.focused);
        if (hasChild && li) {
            li.classList.remove(classNames.focused);
            this.setSelectLI(li, e);
        }
    }
    private spaceKeyHandler(e: KeyboardEventArgs): void {
        if (this.enable && this.showCheckBox) {
            let li: Element = this.curUL.querySelector('.' + classNames.focused);
            this.setCheckboxLI(li, e);
        }
    }

    private keyActionHandler(e: KeyboardEventArgs): void {
        e.preventDefault();
        switch (e.action) {
            case 'home':
                this.homeKeyHandler(e);
                break;
            case 'end':
                this.homeKeyHandler(e, true);
                break;
            case 'moveDown':
                this.arrowKeyHandler(e);
                break;
            case 'moveUp':
                this.arrowKeyHandler(e, true);
                break;
            case 'select':
                this.enterKeyHandler(e);
                break;
            case 'back':
                this.back();
                break;
            case 'tab':
                this.tabFocus(e);
                break;
            case 'space':
                this.spaceKeyHandler(e);
                break;
        }
    }

    private swipeActionHandler(e: SwipeEventArgs): void {
        if (e.swipeDirection === 'Right') {
            this.back();
        }
    }

    private focusout(): void {
        let focusedElement: Element = this.curUL.querySelector('.' + classNames.focused);
        let activeElement: Element = this.curUL.querySelector('[aria-selected = true]');
        if (focusedElement && !this.showCheckBox) {
            focusedElement.classList.remove(classNames.focused);
            if (activeElement) {
                activeElement.classList.add(classNames.selected);
            }
        }
    }

    private wireEvents(): void {
        EventHandler.add(this.element, 'click', this.clickHandler, this);
        EventHandler.add(this.element, 'mouseover', this.hoverHandler, this);
        EventHandler.add(this.element, 'mouseout', this.leaveHandler, this);
        EventHandler.add(this.element, 'focusout', this.focusout, this);
        this.keyboardModule = new KeyboardEvents(
            this.element,
            {
                keyAction: this.keyActionHandler.bind(this),
                keyConfigs: this.keyConfigs
            });
        this.touchModule = new Touch(this.element, { swipe: this.swipeActionHandler.bind(this) });
    }

    private unWireEvents(): void {
        EventHandler.remove(this.element, 'click', this.clickHandler);
        EventHandler.remove(this.element, 'mouseover', this.hoverHandler);
        EventHandler.remove(this.element, 'mouseout', this.leaveHandler);
        this.keyboardModule.destroy();
        this.touchModule.destroy();
    }

    private tabFocus(e: KeyboardEventArgs): void {
        let selectedList: Element = this.curUL.querySelector('.' + classNames.selected);
        if ((!selectedList && this.curUL) || this.showCheckBox) {
            let li: Element = this.curUL.querySelector('.' + classNames.listItem);
            if (li.classList.contains(classNames.hasChild) || this.showCheckBox) {
                let focusedElement: Element = this.curUL.querySelector('.' + classNames.focused);
                if (isNullOrUndefined(focusedElement)) {
                    li.classList.add(classNames.focused);
                }
            } else {
                this.setSelectLI(li, e);

            }
        }
    }

    private removeHover(): void {
        let hoverLI: Element = this.element.querySelector('.' + classNames.hover);
        if (hoverLI) { hoverLI.classList.remove(classNames.hover); }
    }

    private removeSelect(): void {
        let selectedLI: Element[] = <NodeListOf<Element> & Element[]>this.element.querySelectorAll('[aria-selected = true]');
        for (let ele of selectedLI) {
            ele.removeAttribute('aria-selected');
            if (ele.className !== '') {
                ele.classList.remove(classNames.selected);
            }
        }
    }

    private isValidLI(li: Element | HTMLElement): boolean {
        return (li && li.classList.contains(classNames.listItem)
            && !li.classList.contains(classNames.grpListItem)
            && !li.classList.contains(classNames.disable));
    }

    private setCheckboxLI(li: Element, e?: MouseEvent | KeyboardEvent | FocusEvent): void {
        if (this.isValidLI(li) && this.enable && this.showCheckBox) {
            if (this.curUL.querySelector('.' + classNames.focused)) {
                this.curUL.querySelector('.' + classNames.focused).classList.remove(classNames.focused);
            }
            li.classList.add(classNames.focused);
            let checkboxElement: Element = li.querySelector('.' + classNames.checkboxWrapper);
            let checkIcon: HTMLElement = checkboxElement.querySelector('.' + classNames.checkboxIcon + '.' + classNames.icon);
            this.removeHover();
            if (!checkIcon.classList.contains(classNames.checked)) {
                checkIcon.classList.add(classNames.checked);
                li.classList.add(classNames.selected);
            } else {
                checkIcon.classList.remove(classNames.checked);
                li.classList.remove(classNames.selected);
            }
            checkboxElement.setAttribute('aria-checked', checkIcon.classList.contains(classNames.checked) ?
                'true' : 'false');
            if (e) {
                let eventArgs: Object = this.selectEventData(<HTMLElement>li, e);
                merge(eventArgs, { isChecked: checkIcon.classList.contains(classNames.checked) });
                this.trigger('select', eventArgs);
            }
        }
    }

    private selectEventData(li: HTMLElement, e?: MouseEvent | KeyboardEvent | FocusEvent): Object {
        let data: { [key: string]: Object } = this.getItemData(li);
        let fieldData: { [key: string]: Object } = <{ [key: string]: Object }>getFieldValues(data, this.listBaseOption.fields);
        let selectedItem: SelectedItem;
        if (isNullOrUndefined(data) && typeof (this.dataSource as string[])[0] === 'string') {
            selectedItem = { item: li, text: (li as HTMLElement).innerText.trim(), data: this.dataSource as string[] };
        } else {
            selectedItem = { item: li, text: <string>fieldData[this.listBaseOption.fields.text], data: data };
        }
        let eventArgs: Object = {};
        merge(eventArgs, selectedItem);
        if (e) {
            merge(eventArgs, { isInteracted: true, event: e, index: Array.prototype.indexOf.call(this.curUL.children, li) });
        }
        return eventArgs;
    }

    private setSelectLI(li: Element, e?: MouseEvent | KeyboardEvent | FocusEvent): void {
        if (this.isValidLI(li) && !li.classList.contains(classNames.selected) && this.enable) {
            this.removeSelect();
            li.classList.add(classNames.selected);
            li.setAttribute('aria-selected', 'true');
            this.removeHover();
            let eventArgs: Object = this.selectEventData(<HTMLElement>li, e);
            this.trigger('select', eventArgs);
            this.selectedLI = <HTMLElement>li;
            this.renderSubList(li);
        }
    }

    private setHoverLI(li: Element): void {
        if (this.isValidLI(li) && !li.classList.contains(classNames.hover) && this.enable) {
            let lastLi: Element[] = <NodeListOf<Element> & Element[]>this.element.querySelectorAll('.' + classNames.hover);
            if (lastLi && lastLi.length) { removeClass(lastLi, classNames.hover); }
            if (!(li as Element).classList.contains(classNames.selected) || this.showCheckBox) {
                (li as Element).classList.add(classNames.hover);
            }
        }
    }

    private hoverSiblingLI(prev?: boolean): void {
        let lastLi: Element = this.curUL.querySelector('.' + classNames.hover);
        let siblingLI: Element;
        if (!lastLi) { lastLi = this.curUL.querySelector('.' + classNames.selected); }
        if (lastLi) {
            siblingLI = ListBase.getSiblingLI(this.curUL.querySelectorAll('.' + classNames.listItem), lastLi, prev);
        } else {
            if (prev) {
                let curLIs: NodeListOf<Element> = this.curUL.querySelectorAll('.' + classNames.listItem);
                siblingLI = curLIs[curLIs.length - 1];
            } else {
                siblingLI = this.curUL.querySelector('.' + classNames.listItem);
            }
        }
        this.setHoverLI(siblingLI);
    }

    //Data Source Related Functions
    private getSubDS(): { [key: string]: Object }[] {
        let levelKeys: string[] = this.curDSLevel;
        if (levelKeys.length) {
            let ds: { [key: string]: Object }[] = <{ [key: string]: Object }[]>this.localData;
            for (let key of levelKeys) {
                this.curDSJSON = <{ [key: string]: Object }[] & { [key: string]: Object }>this.findItemFromDS(ds, { id: key });
                let fieldData: { [key: string]: Object } = <{ [key: string]: Object }>getFieldValues
                    (this.curDSJSON, this.listBaseOption.fields);
                ds = this.curDSJSON ? <{ [key: string]: Object }[] & { [key: string]: Object }>fieldData[this.fields.child] : ds;
            }
            return ds;
        }
        return <{ [key: string]: Object }[]>this.localData;
    }

    private getItemData(li: Element | Fields): { [key: string]: Object } {
        let fields: Fields = this.getElementUID(li);
        let curDS: { [key: string]: Object }[] = <{ [key: string]: Object }[]>this.dataSource;
        return <{ [key: string]: Object }>this.findItemFromDS(curDS, fields);
    }

    private findItemFromDS(
        dataSource: { [key: string]: Object }[],
        fields: Fields, parent?: boolean): { [key: string]: Object }[] | { [key: string]: Object } {

        let resultJSON: { [key: string]: Object }[] | { [key: string]: Object };

        if (dataSource && dataSource.length && fields) {
            dataSource.some((data: { [key: string]: Object }) => {
                let fieldData: { [key: string]: Object } = <{ [key: string]: Object }>getFieldValues(data, this.listBaseOption.fields);
                //(!(fid) || id === fid) && (!(ftext) || text === ftext) && (!!fid || !!ftext)
                if ((fields.id || fields.text) &&
                    (!fields.id || fieldData[this.fields.id] === fields.id) &&
                    (!fields.text || fieldData[this.fields.text] === fields.text)) {
                    resultJSON = (parent ? <{ [key: string]: Object }[] | { [key: string]: Object }>dataSource : data);
                } else if (!isNullOrUndefined(fields.id) && isNullOrUndefined(fieldData[this.fields.id])) {
                    let li: Element = this.element.querySelector('[data-uid="'
                        + fields.id + '"]');
                    if ((li as HTMLElement).innerText.trim() === fieldData[this.fields.text]) {
                        resultJSON = data;
                    }
                } else if ((fieldData as Object).hasOwnProperty(this.fields.child) && (fieldData[this.fields.child] as Object[]).length) {
                    resultJSON = <{ [key: string]: Object } & { [key: string]: Object }[]>this.findItemFromDS(
                        <{ [key: string]: Object }[]>fieldData[this.fields.child], fields, parent);
                }
                return !!resultJSON;
            });
        } else {
            resultJSON = <{ [key: string]: Object }[] & { [key: string]: Object }>dataSource;
        }

        return <{ [key: string]: Object }[] & { [key: string]: Object }>resultJSON;
    }

    private getQuery(): Query {
        let columns: string[] = [];
        let query: Query = (this.query ? this.query : new Query());
        if (!this.query) {
            for (let column of Object.keys((this.fields as ListViewModel & { properties: Object }).properties)) {
                if (column !== 'tableName' && !!((this.fields as { [key: string]: Object })[column]) &&
                    (this.fields as { [key: string]: Object })[column] !==
                    (ListBase.defaultMappedFields as { [key: string]: Object })[column]
                    && columns.indexOf((this.fields as { [key: string]: string })[column]) === -1) {

                    columns.push((this.fields as { [key: string]: string })[column]);

                }
            }
            query.select(columns);
            if ((this.fields as ListViewModel & { properties: Object }).properties.hasOwnProperty('tableName')) {
                query.from(this.fields.tableName);
            }
        }

        return query;
    }

    private setViewDataSource(
        dataSource: { [key: string]: Object }[] = <{ [key: string]: Object }[]>this.localData): void {

        if (dataSource && this.fields.groupBy) {
            this.curViewDS = ListBase.groupDataSource(dataSource, this.fields, this.sortOrder);
        } else if (dataSource && this.sortOrder !== 'None') {
            this.curViewDS = ListBase.getDataSource(dataSource, ListBase.addSorting(this.sortOrder, this.fields.sortBy));
        } else {
            this.curViewDS = dataSource;
        }
    }

    private isInAnimation(): boolean {
        return this.curUL.classList.contains('.e-animate');
    }

    private setLocalData(): void {
        this.trigger('actionBegin');
        if (this.dataSource instanceof DataManager) {
            (this.dataSource as DataManager).executeQuery(this.getQuery()).then((e: Object) => {
                if (this.isDestroyed) { return; }
                this.localData = (e as ResultData).result;
                this.renderList();
                this.trigger('actionComplete', e);
            }).catch((e: Object) => {
                if (this.isDestroyed) { return; }
                this.trigger('actionFailure', e);
            });
        } else if (!this.dataSource || !(<{ [key: string]: Object }[]>this.dataSource).length) {
            let ul: HTMLElement = <HTMLElement>this.element.querySelector('ul');
            if (ul) {
                remove(ul);
                this.setProperties({ dataSource: ListBase.createJsonFromElement(ul) }, true);
                this.localData = <{ [key: string]: Object }[]>this.dataSource;
                this.renderList();
                this.trigger('actionComplete', { data: this.localData });
            }
        } else {
            this.localData = <{ [key: string]: Object }[]>this.dataSource;
            this.renderList();
            this.trigger('actionComplete', { data: this.localData });
        }
    }

    private reRender(): void {
        this.element.innerHTML = '';
        this.curUL = this.headerEle = undefined;
        this.setLocalData();
        this.header();
    }

    private resetCurrentList(): void {
        this.setViewDataSource(this.curViewDS);
        this.contentContainer.innerHTML = '';
        this.createList();
        this.renderIntoDom(this.curUL);
    }

    private createList(): void {
        this.currentLiElements = [];
        this.ulElement = this.curUL = ListBase.createList(this.curViewDS, this.listBaseOption);
        this.liCollection = <HTMLElement[] & NodeListOf<Element>>this.curUL.querySelectorAll('.' + classNames.listItem);
    }

    private renderSubList(li: Element): void {
        let uID: string = li.getAttribute('data-uid');
        if (li.classList.contains(classNames.hasChild) && uID) {
            let ul: Element = closest(li.parentNode, '.' + classNames.parentItem);
            let ele: Element = this.element.querySelector('[pid=\'' + uID + '\']');
            this.curDSLevel.push(uID);
            this.setViewDataSource(this.getSubDS());
            if (!ele) {
                ele = <Element>ListBase.createListFromJson(this.curViewDS, this.listBaseOption, this.curDSLevel.length);
                ele.setAttribute('pID', <string>uID);
                (ele as HTMLElement).style.display = 'none';
                this.renderIntoDom(ele);
            }
            this.switchView(<HTMLElement>ul, <HTMLElement>ele);
            this.liCollection = <HTMLElement[] & NodeListOf<Element>>this.curUL.querySelectorAll('.' + classNames.listItem);
            let fieldData: { [key: string]: Object } = <{ [key: string]: Object }>
                getFieldValues(<{ [key: string]: Object } | string | string[]>this.getSelectedItems().data, this.listBaseOption.fields);
            this.header(<string>(fieldData[this.listBaseOption.fields.text]), true);
            this.selectedLI = undefined;
        }
    }

    private renderIntoDom(ele: Element): void {
        this.contentContainer.appendChild(ele);
    }

    private renderList(): void {
        this.setViewDataSource();
        this.createList();
        this.contentContainer = createElement('div', { className: classNames.content });
        this.element.appendChild(this.contentContainer);
        this.renderIntoDom(this.ulElement);
    }

    private getElementUID(obj: Fields | HTMLElement): Fields {
        let fields: Fields = {};
        if (obj instanceof Element) {
            fields.id = obj.getAttribute('data-uid');
        } else {
            fields = <Fields>obj;
        }
        return fields;
    }

    /**
     * It is used to Initialize the control rendering.
     */
    public render(): void {
        this.element.classList.add(classNames.root);
        attributes(this.element, { role: 'list', tabindex: '0' });
        this.setCSSClass();
        this.setEnableRTL();
        this.setEnable();
        this.setSize();
        this.wireEvents();
        this.header();
        this.setLocalData();
        this.setHTMLAttribute();
        this.rippleFn = rippleEffect(this.element, {
            selector: '.' + classNames.listItem
        });
    }


    /**
     * It is used to destroy the ListView component.
     */
    public destroy(): void {
        this.unWireEvents();
        let classAr: string[] = [classNames.root, this.cssClass, classNames.disable, 'e-rtl',
            'e-has-header'];
        removeClass([this.element], classAr);
        this.rippleFn();
        super.destroy();
    }

    /**
     * It helps to switch back from navigated sub list.
     */
    public back(): void {
        let pID: string = this.curDSLevel[this.curDSLevel.length - 1];
        if (pID === undefined || this.isInAnimation()) { return; }
        this.curDSLevel.pop();
        this.setViewDataSource(this.getSubDS());
        let toUL: HTMLElement = <HTMLElement>this.element.querySelector('[data-uid=\'' + pID + '\']');
        let fromUL: HTMLElement = this.curUL;
        if (!toUL) {
            this.createList();
            this.renderIntoDom(this.ulElement);
            toUL = this.curUL;
        } else {
            toUL = toUL.parentElement;
        }
        let fieldData: { [key: string]: Object } = <{ [key: string]: Object }>getFieldValues(this.curDSJSON, this.listBaseOption.fields);
        let text: string = <string>fieldData[this.fields.text];
        this.switchView(fromUL, toUL, true);
        this.removeSelect();
        this.liCollection = <HTMLElement[] & NodeListOf<Element>>this.curUL.querySelectorAll('.' + classNames.listItem);
        this.header((this.curDSLevel.length ? text : this.headerTitle), (this.curDSLevel.length ? true : false));
    }

    /**
     * It is used to select the list item from the ListView.
     * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
     */
    public selectItem(obj: Fields | HTMLElement): void {
        if (!isNullOrUndefined(obj)) {
            if (this.showCheckBox) {
                this.setCheckboxLI(this.getLiFromObjOrElement(obj));
            } else {
                this.setSelectLI(this.getLiFromObjOrElement(obj));
            }
        }
    }

    private getLiFromObjOrElement(obj: Fields | HTMLElement): HTMLElement {
        let li: Element;
        if (!isNullOrUndefined(obj)) {
            if (typeof (this.dataSource as string[])[0] === 'string') {
                let uid: string = (obj as HTMLElement).getAttribute('data-uid').toString();
                for (let i: number = 0; i < this.liCollection.length; i++) {
                    if (this.liCollection[i].getAttribute('data-uid').toString() === uid) {
                        li = this.liCollection[i] as HTMLElement;
                        break;
                    }
                }
            } else {
                let resultJSON: { [key: string]: Object }[] | { [key: string]: Object } = this.getItemData(obj);
                let fieldData: { [key: string]: Object } =
                    <{ [key: string]: Object }>getFieldValues(resultJSON, this.listBaseOption.fields);
                if (resultJSON) {
                    li = this.element.querySelector('[data-uid="'
                        + (<{ [key: string]: Object }>fieldData)[this.fields.id] + '"]');
                    if (isNullOrUndefined(li)) {
                        let curLi: NodeListOf<Element> = this.element.querySelectorAll('.' + classNames.listItem);
                        for (let i: number = 0; i < curLi.length; i++) {
                            if ((curLi[i] as HTMLElement).innerText.trim() === resultJSON.text) {
                                li = curLi[i];
                            }
                        }
                    }
                }
            }
        }
        return <HTMLElement>li;
    }

    public selectMultipleItems(obj: Fields[] | HTMLElement[]): void {
        if (!isNullOrUndefined(obj)) {
            for (let i: number = 0; i < obj.length; i++) {
                if (!isNullOrUndefined(obj[i])) {
                    this.selectItem(obj[i]);
                }
            }
        }
    }

    /**
     * It is used to get the currently
     *  {@link http://ej2.syncfusion.com/documentation/list-view/api-selectedItem.html?lang=typescript selected}
     *  item details from the list items.
     */
    public getSelectedItems(): SelectedItem | SelectedCollection {
        this.selectedId = [];
        if (this.showCheckBox) {
            let liCollection: HTMLCollection = <HTMLCollection>this.element.getElementsByClassName(classNames.selected);
            let liTextCollection: string[] = []; let liDataCollection: { [key: string]: Object }[] = []; this.selectedId = [];
            for (let i: number = 0; i < liCollection.length; i++) {
                if (typeof (this.dataSource as string[])[0] === 'string') {
                    liTextCollection.push((liCollection[i] as HTMLElement).innerText.trim());
                } else {
                    let fieldData: { [key: string]: Object } =
                        <{ [key: string]: Object }>getFieldValues(this.getItemData(liCollection[i]), this.listBaseOption.fields);
                    liTextCollection.push(<string>fieldData[this.listBaseOption.fields.text]);
                    liDataCollection.push(this.getItemData(liCollection[i]));
                    this.selectedId.push(<string>fieldData[this.listBaseOption.fields.id]);
                }
            }
            if (typeof (this.dataSource as string[])[0] === 'string') {
                return { item: liCollection, data: this.dataSource as string[], text: liTextCollection };
            } else {
                return { item: liCollection, data: liDataCollection, text: liTextCollection };
            }
        } else {
            let liElement: Element = this.element.getElementsByClassName(classNames.selected)[0];
            let fieldData: { [key: string]: Object } =
                <{ [key: string]: Object }>getFieldValues(this.getItemData(liElement), this.listBaseOption.fields);
            if (typeof (this.dataSource as string[])[0] === 'string') {
                return (!isNullOrUndefined(liElement)) ? {
                    item: liElement, data: this.dataSource as string[],
                    text: (liElement as HTMLElement).innerText.trim()
                } : undefined;
            } else {
                if (isNullOrUndefined(fieldData) || isNullOrUndefined(liElement)) {
                    return undefined;
                } else {
                    this.selectedId.push(<string>fieldData[this.listBaseOption.fields.id]);
                    return { text: <string>fieldData[this.listBaseOption.fields.text], item: liElement,
                        data: this.getItemData(liElement) };
                }
            }
        }
    }

    /**
     * It is used to find out an item details from the current list.
     * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
     */
    public findItem(fields: Fields): SelectedItem {
        return <SelectedItem & { [key: string]: Object }>this.findItemFromDS(<{ [key: string]: Object }[]>this.dataSource, fields);
    }

    /**
     * A function that used to enable the disabled list items based on passed element.
     * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
     */
    public enableItem(obj: Fields | HTMLElement): void {
        this.setItemState(obj, true);
    }

    /**
     * It is used to disable the list items based on passed element.
     * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
     */
    public disableItem(obj: Fields | HTMLElement): void {
        this.setItemState(obj, false);
    }

    //A function that used to set state of the list item like enable, disable.
    private setItemState(obj: Fields | HTMLElement, isEnable: boolean): void {
        let resultJSON: { [key: string]: Object } = this.getItemData(obj);
        let fieldData: { [key: string]: Object } = <{ [key: string]: Object }>getFieldValues(resultJSON, this.listBaseOption.fields);
        if (resultJSON) {
            let li: Element = this.element.querySelector('[data-uid="' + fieldData[this.fields.id] + '"]');
            if (isEnable) {
                if (li) { li.classList.remove(classNames.disable); }
                delete resultJSON[this.fields.enabled];
            } else if (!isEnable) {
                if (li) { li.classList.add(classNames.disable); }
                resultJSON[this.fields.enabled] = false;
            }
        }
    }

    /**
     * It is used to show an list item from the ListView.
     * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
     */
    public showItem(obj: Fields | HTMLElement): void {
        this.showHideItem(obj, false, '');
    }

    /**
     * It is used to hide an item from the ListView.
     * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
     */
    public hideItem(obj: Fields | HTMLElement): void {
        this.showHideItem(obj, true, 'none');
    }

    private showHideItem(obj: Fields | HTMLElement, isHide: boolean, display: string): void {
        let resultJSON: { [key: string]: Object } = this.getItemData(obj);
        let fieldData: { [key: string]: Object } = <{ [key: string]: Object }>getFieldValues(resultJSON, this.listBaseOption.fields);
        if (resultJSON) {
            let li: HTMLElement = <HTMLElement>this.element.querySelector('[data-uid="' + fieldData[this.fields.id] + '"]');
            if (li) { li.style.display = display; }
            if (isHide) {
                resultJSON[this.fields.isVisible] = false;
            } else {
                delete resultJSON[this.fields.isVisible];
            }
        }
    }

    /**
     * It adds new item to current ListView.
     * To add a new item in the list view, we need to pass ‘data’ as array or object and ‘fields’ as object.
     * For example fields: { text: 'Name', tooltip: 'Name', id:'id'}
     * @param  {{[key:string]:Object}[]} data - Array JSON Data that need to add.
     * @param  {Fields} fields - Fields as an Object with ID and Text fields.
     */
    public addItem(data: { [key: string]: Object }[], fields: Fields): void {
        let ds: { [key: string]: Object } = <{ [key: string]: Object }>this.findItemFromDS(
            <{ [key: string]: Object }[]>this.dataSource, fields);
        let fieldData: { [key: string]: Object } = <{ [key: string]: Object }>getFieldValues(ds, this.listBaseOption.fields);
        let child: { [key: string]: Object }[] = <{ [key: string]: Object }[]>fieldData[this.fields.child];
        if (!child) {
            child = [];
        }
        child = child.concat(data);
        if (ds instanceof Array) {
            this.dataSource = this.localData = <{ [key: string]: Object }[]>(ds as Object[] & { [key: string]: Object }).concat(data);
            this.setViewDataSource();
        } else {
            ds[this.fields.child] = child;
        }
        this.resetCurrentList();
    }

    /**
     * A function that removes the item from data source based on passed element like fields: { text: 'Name', tooltip: 'Name', id:'id'}
     * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
     */
    public removeItem(obj: Element | Fields): void {
        this.removeItemFromList(obj, true);
    }

    private removeItemFromList(obj: Fields | Element, resetList?: boolean): void {
        let currentlySelectedItems: HTMLElement[] = [];
        let selectedElements: { [key: string]: object }[] = [];
        let valid: boolean = false;
        if (typeof (this.dataSource as string[])[0] === 'string') {
            if (typeof (obj as HTMLElement) === 'object') {
                let liCollection: HTMLElement[] = []; let idx: number = 0;
                this.liCollection.forEach((element: HTMLElement) => {
                    if (element === obj) {
                        valid = true;
                        this.removeElement(element);
                        (this.dataSource as string[]).splice(idx, 1);
                        this.localData = <{ [key: string]: Object }[]>this.dataSource;
                    } else {
                        liCollection.push(element);
                    }
                    idx++;
                });
                this.liCollection = liCollection;
            } else if (typeof obj === 'string') {
                let liCollection: HTMLElement[] = []; let idx: number = 0;
                let ds: { [key: string]: Object }[] = [];
                this.liCollection.forEach((element: HTMLElement) => {
                    if (element.innerText.trim() === obj) {
                        valid = true;
                        this.removeElement(element);
                    } else {
                        liCollection.push(element);
                        ds.push((this.dataSource as { [key: string]: Object }[])[idx]);
                    }
                    idx++;
                });
                this.localData = this.curViewDS = this.dataSource = ds;
                this.liCollection = liCollection;
            }
            let values: SelectedCollection | SelectedItem = this.getSelectedItems();
            this.selectedData = (!isNullOrUndefined(values)) ? <string[] | string>values.text : undefined;
            selectedElements = undefined;
            if (resetList && valid) {
                this.resetList = true;
                this.resetCurrentList();
                if (!this.showCheckBox && this.selectedData && this.selectedData.length) {
                    this.removeSelect();
                    let index: number = (this.dataSource as string[]).lastIndexOf(this.selectedData as string);
                    this.liCollection[index].classList.add(classNames.selected);
                    this.liCollection[index].setAttribute('aria-selected', 'true');
                }
                this.resetList = false;
            }
        } else {
            selectedElements = (!isNullOrUndefined(this.getSelectedItems())) ?
                this.getSelectedItems().data as { [key: string]: object }[] : undefined;
            let fields: Fields = this.getElementUID(obj);
            let curAr: { [key: string]: Object }[];
            let curDS: Object[] | Object = this.findItemFromDS(<{ [key: string]: Object }[]>this.dataSource, fields, true);
            if (curDS && obj) {
                let idx: number;
                (curDS as Object[]).some((data: { [key: string]: Object }, index: number, arr: { [key: string]: Object }[]): boolean => {
                    let fieldData: { [key: string]: Object } = <{ [key: string]: Object }>getFieldValues(data, this.listBaseOption.fields);
                    if ((fields.id || fields.text) &&
                        (!fields.id || fieldData[this.fields.id] === fields.id) &&
                        (!fields.text || fieldData[this.fields.text] === fields.text)) {
                        curAr = arr;
                        idx = index;
                        return true;
                    }
                    return false;
                });
                this.removeElement(this.getLiFromObjOrElement(curAr[idx]));
                curAr.splice(idx, 1);
                this.curViewDS = curAr;
            }
            let values: SelectedCollection | SelectedItem = this.getSelectedItems();
            this.selectedData = (!isNullOrUndefined(values)) ? <string[]>values.text : undefined;
            if (resetList && curAr) {
                this.resetList = true;
                this.resetCurrentList();
                if (!this.showCheckBox && !isNullOrUndefined(values)) {
                    this.selectItem(<HTMLElement>values.item);
                }
                this.resetList = false;
            }
        }
    }

    /**
     * A function that removes multiple item from list view based on given input.
     * @param  {Fields[] | HTMLElement[]} obj - We can pass array of elements or array of field Object with ID and Text fields.
     */
    public removeMultipleItems(obj: HTMLElement[] | Fields[]): void {
        if (obj.length) {
            for (let i: number = 0; i < obj.length; i++) {
                (i === obj.length - 1) ? this.removeItemFromList(obj[i], true) : this.removeItemFromList(obj[i], false);
            }
        }
    }

    // Module Required function
    protected getModuleName(): string {
        return 'listview';
    }

    /**
     * Get the properties to be maintained in the persisted state.
     */
    protected getPersistData(): string {
        return this.addOnPersist(['cssClass', 'enableRtl', 'htmlAttributes',
            'enable', 'fields', 'animation', 'headerTitle',
            'sortOrder', 'showIcon', 'height', 'width', 'showCheckBox', 'checkBoxPosition']);
    }

}

interface ResultData {
    result: { [key: string]: Object }[];
}

interface ClassNames {
    root: string;
    hover: string;
    focused: string;
    selected: string;
    parentItem: string;
    listItem: string;
    hasChild: string;
    view: string;
    header: string;
    text: string;
    headerText: string;
    listItemText: string;
    grpListItem: string;
    disable: string;
    content: string;
    backIcon: string;
    icon: string;
    checkboxWrapper: string;
    checkbox: string;
    checked: string;
    checkboxIcon: string;
    checkboxRight: string;
    checkboxLeft: string;
}

export interface SelectedItem {
    /**
     * It denotes the Selected Item text.
     */
    text: string;

    /**
     * It denotes the Selected Item list element.
     */
    item: HTMLElement | Element;

    /**
     * It denotes the Selected Item dataSource JSON object.
     */
    data: { [key: string]: Object } | string[];
}

export interface SelectedCollection {
    /**
     * It denotes the Selected Item text data or collection.
     */
    text: string | string[];

    /**
     * It denotes the Selected Item list element or element collection.
     */
    item: HTMLElement | Element[] | HTMLCollection;

    /**
     * It denotes the Selected Item dataSource JSON object or object collection.
     */
    data: { [key: string]: Object } | { [key: string]: Object }[] | string[];
}

export interface SelectEventArgs extends BaseEventArgs, SelectedItem {
    /**
     * Specifies that event has triggered by user interaction.
     */
    isInteracted: boolean;
    /**
     * Specifies that event argument when event raised by other event.
     */
    event: MouseEvent | KeyboardEvent;
    /**
     * It is used to denote the index of the selected element.
     */
    index: number;
    /**
     * It is used to check whether the element is checked or not.
     */
    isChecked?: boolean;
}
export interface ItemCreatedArgs {
    curData: { [key: string]: Object };
    dataSource: { [key: string]: Object } | string[];
    fields: FieldsMapping;
    item: HTMLElement;
    options: ListBaseOptions;
    text: string;
}
