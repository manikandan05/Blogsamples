import { Component, Property, Event, Collection, L10n, Browser, EmitType, Complex } from '@syncfusion/ej2-base';
import { createElement, addClass, removeClass, detach, attributes, prepend, setStyleAttribute } from '@syncfusion/ej2-base';
import { NotifyPropertyChanges, INotifyPropertyChanged, ChildProperty } from '@syncfusion/ej2-base';
import { isNullOrUndefined, formatUnit } from '@syncfusion/ej2-base';
import { ButtonPropsModel, DialogModel, AnimationSettingsModel } from './dialog-model';
import { EventHandler } from '@syncfusion/ej2-base';
import { Draggable } from '@syncfusion/ej2-base';
import { Popup, PositionData, getZindexPartial } from '../popup/popup';
import { PositionDataModel } from '../popup/popup-model';
import { Button, ButtonModel } from '@syncfusion/ej2-buttons';

export class ButtonProps extends ChildProperty<ButtonProps> {
    /**
     * Specifies the Button component properties to render the Dialog buttons.
     */
    @Property()
    public buttonModel: ButtonModel;

    /**
     * Event triggers when `click` the Dialog button.
     * @event
     */
    @Property()
    public click: EmitType<Object>;
}

/**
 * Specifies Dialog open and close animation settings. 
 */
export class AnimationSettings extends ChildProperty<AnimationSettings> {
    /**
     * Specifies the effect to open and close the Dialog.  
     * If the user sets `Fade` effect then the Dialog will open with 'FadeIn' effect and close with 'FadeOut' effect.
     * Following list of effects will be available, you can use any of this.
     * 1. 'Fade'
     * 2. 'FadeZoom'
     * 3. 'FlipLeftDown'
     * 4. 'FlipLeftUp'
     * 5. 'FlipRightDown'
     * 6. 'FlipRightUp'
     * 7. 'FlipXDown'
     * 8. 'FlipXUp'
     * 9. 'FlipYLeft'
     * 10. 'FlipYRight'
     * 11. 'SlideBottom'
     * 12. 'SlideLeft'
     * 13. 'SlideRight'
     * 14. 'SlideTop'
     * 15. 'Zoom'
     * 16. 'None'
     */
    @Property('Fade')
    public effect: DialogEffect;

    /**
     * Specifies the animation `duration` to complete with one animation cycle.
     */
    @Property(400)
    public duration: number;

    /**
     * Specifies the `delay` value in milliseconds to wait before animation begins.
     */
    @Property(0)
    public delay: number;
}

/**
 * Specifies the Dialog animation effects.
 */
export type DialogEffect = 'Fade' | 'FadeZoom' | 'FlipLeftDown' | 'FlipLeftUp' | 'FlipRightDown' | 'FlipRightUp'
    | 'FlipXDown' | 'FlipXUp' | 'FlipYLeft' | 'FlipYRight' | 'SlideBottom' | 'SlideLeft' | 'SlideRight' | 'SlideTop' | 'Zoom'
    | 'None';

const ROOT: string = 'e-dialog';
const RTL: string = 'e-rtl';
const DLG_HEADER_CONTENT: string = 'e-dlg-header-content';
const DLG_HEADER: string = 'e-dlg-header';
const DLG_FOOTER_CONTENT: string = 'e-footer-content';
const MODAL_DLG: string = 'e-dlg-modal';
const DLG_CONTENT: string = 'e-dlg-content';
const DLG_CLOSE_ICON: string = 'e-icon-dlg-close';
const DLG_OVERLAY: string = 'e-dlg-overlay';
const DLG_CONTAINER: string = 'e-dlg-container';
const SCROLL_DISABLED: string = 'e-scroll-disabled';
const DLG_PRIMARY_BUTTON: string = 'e-primary';
const ICON: string = 'e-icons';
const POPUP_ROOT: string = 'e-popup';
const DEVICE: string = 'e-device';
const FULLSCREEN: string = 'e-dlg-fullscreen';
const DLG_CLOSE_ICON_BTN: string = 'e-dlg-closeicon-btn';
const DLG_HIDE: string = 'e-popup-close';
const DLG_SHOW: string = 'e-popup-open';


export interface BeforeOpenEventArgs {
    cancel: boolean;
    container: HTMLElement;
}

export interface BeforeCloseEventArgs {
    cancel: boolean;
    container: HTMLElement;
}

/**
 * Represents the Dialog component that displays information to the user, and used to get the user input.
 * ```html
 * <div id="dialog"></div>
 * ```
 * ```typescript
 * <script>
 *   var dialogObj = new Dialog({ header: 'Dialog' });
 *   dialogObj.appendTo("#dialog");
 * </script>
 * ```
 */

@NotifyPropertyChanges
export class Dialog extends Component<HTMLElement> implements INotifyPropertyChanged {
    // Internal variables
    private closeIconClickEventHandler: Function;
    private dlgOverlayClickEventHandler: Function;
    private createEventHandler: Function;
    private contentEle: HTMLElement;
    private dlgOverlay: HTMLElement;
    private dlgContainer: HTMLElement;
    private headerEle: HTMLElement;
    private buttonContent: string[];
    private ftrTemplateContent: HTMLElement;
    private headerContent: HTMLElement;
    private closeIcon: HTMLElement;
    private popupObj: Popup;
    private btnObj: Button[];
    private closeIconBtnObj: Button;
    private dragObj: Draggable;
    private primaryButtonEle: HTMLElement;
    private targetEle: HTMLElement;
    private dialogOpen: boolean;
    private storeActiveElement: HTMLElement;
    private focusElements: HTMLElement[];
    private focusIndex: number;
    private closedFrom: Object;
    private l10n: L10n;
    private clonedEle: HTMLElement;
    /**
     * Specifies the `content` to be displayed in Dialog, it can be text or HTML element.
     * @default ''
     */
    @Property('')
    public content: string | HTMLElement;
    /**
     * Specifies the value to either show or hide the close icon button.
     * @default false
     */
    @Property(false)
    public showCloseIcon: boolean;
    /**
     * Specifies the value to render the Dialog as modal or modeless.
     * @default false
     */
    @Property(false)
    public isModal: boolean;
    /**
     * Specifies the `header` content that defines how the Dialog `header` is rendered. 
     * @default ''
     */
    @Property('')
    public header: string;
    /**
     * Specifies the value to either Dialog is opened or not.
     * @default true 
     */
    @Property(true)
    public visible: boolean;
    /**
     * Specifies the `height` of the Dialog. 
     * @default 'auto'
     */
    @Property('auto')
    public height: string | number;
    /**
     * Specifies the `width` of the Dialog. 
     * @default '100%'
     */
    @Property('100%')
    public width: string | number;
    /**
     * Specifies the CSS class name to be added for Dialog element.
     * User can add single or multiple CSS classes.
     * @default ''
     */
    @Property('')
    public cssClass: string;
    /**
     * Specifies the z-index value for Dialog.
     */
    @Property(1000)
    public zIndex: number;
    /**
     * Specifies the `target` element where the Dialog should be displayed.
     * If the user set the specific `target` element for Dialog, it will be positioned based on the `target`.
     * @default null
     */
    @Property(null)
    public target: HTMLElement | string;
    /**
     * Specifies the template content to defines how the Dialog footer is rendered. 
     * @default ''
     */
    @Property('')
    public footerTemplate: string;
    /**
     * Specifies the value to either enable or disable draggable option in Dialog. 
     * @default false
     */
    @Property(false)
    public allowDragging: boolean;
    /**
     * Specifies the collection of Dialog `buttons` with click action and button component model.     
     * @default [{}]   
     */
    @Collection<ButtonPropsModel>([{}], ButtonProps)
    public buttons: ButtonPropsModel[];
    /**
     * Specifies the Dialog that is closed when user press the ESC key. 
     * @default true
     */
    @Property(true)
    public closeOnEscape: boolean;
    /**
     * Specifies the Dialog animation settings.
     * @default { effect: 'Fade', duration: 400, delay:0 }
     */
    @Complex<AnimationSettingsModel>({}, AnimationSettings)
    public animationSettings: AnimationSettingsModel;
    /**
     * Specifies to `position` the Dialog on built-in 9 places or any custom location with
     * respect to the associated target elements.
     * For ex: {X:'left', Y:'top'} or { X: 100, Y: 100 }.
     * Following list of positions are available.
     * * for X is: left, center, right (or) any offset value
     * * for Y is: top, center, bottom (or) any offset value
     * @default {X:'center', Y:'center'}
     */
    @Complex<PositionDataModel>({ X: 'center', Y: 'center' }, PositionData)
    public position: PositionDataModel;
    /**
     * Event triggers when the Dialog is `created`. 
     * @event
     */
    @Event()
    public created: EmitType<Object>;
    /**
     * Event triggers once Dialog is opened.
     * @event
     */
    @Event()
    public open: EmitType<Object>;
    /**
     * Event triggers before open the Dialog. 
     * @event
     */
    @Event()
    public beforeOpen: EmitType<BeforeOpenEventArgs>;
    /**
     * Event triggers once the Dialog is closed.
     * @event
     */
    @Event()
    public close: EmitType<Object>;
    /**
     * Event triggers before close the Dialog.
     * @event
     */
    @Event()
    public beforeClose: EmitType<BeforeCloseEventArgs>;
    /**
     * Event triggers when user starts to drag the Dialog. 
     * @event
     */
    @Event()
    public dragStart: EmitType<Object>;
    /**
     * Event triggers when the user stops dragging the Dialog.
     * @event
     */
    @Event()
    public dragStop: EmitType<Object>;
    /**
     * Event triggers when the user drags Dialog. 
     * @event
     */
    @Event()
    public drag: EmitType<Object>;
    /**
     * Event triggers when modal Dialog overlay is clicked. 
     * @event
     */
    @Event()
    public overlayClick: EmitType<Object>;
    /**
     * Constructor for creating the widget    
     * @hidden
     */
    constructor(options?: DialogModel, element?: string | HTMLElement) {
        super(options, <HTMLElement | string>element);
    }
    /**    
     * Initialize the control rendering
     * @private
     */
    public render(): void {
        this.initialize();
        this.initRender();
        this.wireEvents();
    }
    /**
     * Initialize the event handler
     * @private
     */
    protected preRender(): void {
        this.headerContent = null;
        let classArray: string[] = [];
        for (let j: number = 0; j < this.element.classList.length; j++) {
            if (!isNullOrUndefined(this.element.classList[j].match('e-control')) ||
                !isNullOrUndefined(this.element.classList[j].match(ROOT))) {
                classArray.push( this.element.classList[j]);
            }
        }
        removeClass([this.element], classArray);
        this.clonedEle = <HTMLElement>this.element.cloneNode(true);
        this.closeIconClickEventHandler = (event: Event): void => {
            this.hide();
            this.closedFrom = event;
        };
        this.dlgOverlayClickEventHandler = (event: Object): void => {
            this.trigger('overlayClick', event);
        };
        let localeText: object = { close: 'Close' };
        this.l10n = new L10n('dialog', localeText, this.locale);
    };

    private keyDown(event: KeyboardEvent): void {
        if (event.keyCode === 9) {
            if (this.isModal) {
                let buttonObj: Button;
                if (!isNullOrUndefined(this.btnObj)) {
                    buttonObj = this.btnObj[this.btnObj.length - 1];
                }
                if (!isNullOrUndefined(buttonObj) && document.activeElement === buttonObj.element && !event.shiftKey) {
                    event.preventDefault();
                    this.focusableElements(this.element).focus();
                }
                if (document.activeElement === this.focusableElements(this.element) && event.shiftKey) {
                    event.preventDefault();
                    if (!isNullOrUndefined(buttonObj)) {
                        buttonObj.element.focus();
                    }
                }
            }
        }
        let element: HTMLElement = <HTMLElement>document.activeElement;
        let isTagName: boolean = (['input', 'textarea'].indexOf(element.tagName.toLowerCase()) > -1);
        let isContentEdit: boolean = false;
        if (!isTagName) {
            isContentEdit = element.hasAttribute('contenteditable') && element.getAttribute('contenteditable') === 'true';
        }
        if (event.keyCode === 27 && this.closeOnEscape) {
            this.hide();
            this.closedFrom = event;
        }
        if ((event.keyCode === 13 && !event.ctrlKey && element.tagName.toLowerCase() !== 'textarea' &&
                isTagName && !isNullOrUndefined(this.primaryButtonEle)) ||
            (event.keyCode === 13 && event.ctrlKey && (element.tagName.toLowerCase() === 'textarea' ||
                isContentEdit)) && !isNullOrUndefined(this.primaryButtonEle)) {
            let buttonIndex: number;
            let firstPrimary: boolean = this.buttons.some((data: { [key: string]: Object }, index: number) => {
                buttonIndex = index;
                let buttonModel: { [key: string]: Object } = (data.buttonModel as { [key: string]: Object });
                return !isNullOrUndefined(buttonModel) && buttonModel.isPrimary === true;
            });
            if (firstPrimary && typeof (this.buttons[buttonIndex].click) === 'function') {
                setTimeout(() => {
                    this.buttons[buttonIndex].click.call(this, event);
                });
            }
        }
    }
    /**
     * Initialize the control rendering
     * @private 
     */
    private initialize(): void {
        if (!isNullOrUndefined(this.target)) {
            this.targetEle = ((typeof this.target) === 'string') ?
                <HTMLElement>document.querySelector(<string>this.target) : <HTMLElement>this.target;
        }
        addClass([this.element], ROOT);
        if (Browser.isDevice) {
            addClass([this.element], DEVICE);
        }
        this.setCSSClass();
        this.setMaxHeight();
    }
    /**
     * Initialize the rendering
     * @private
     */
    private initRender(): void {
        attributes(this.element, { role: 'dialog' });
        if (this.zIndex === 1000) {
            this.zIndex = getZindexPartial(this.element);
        }
        this.setTargetContent();
        if (this.header !== '') {
            this.setHeader();
        }
        if (this.showCloseIcon) {
            this.renderCloseIcon();
        }
        if (!isNullOrUndefined(this.content) && this.content !== '') {
            this.setContent();
        } else if (this.element.hasChildNodes()) {
            this.contentEle = this.element;
        }
        if (this.footerTemplate !== '') {
            this.setFooterTemplate();
        }
        if (!isNullOrUndefined(this.buttons[0].buttonModel) && this.footerTemplate === '') {
            this.setButton();
        }
        if (this.allowDragging && (!this.isModal) && (!isNullOrUndefined(this.headerContent))) {
            this.setAllowDragging();
        }
        attributes(this.element, { 'aria-modal': (this.isModal ? 'true' : 'false') });
        if (this.isModal) {
            this.setIsModal();
        }
        if (!isNullOrUndefined(this.targetEle)) {
            this.isModal ? this.targetEle.appendChild(this.dlgContainer) : this.targetEle.appendChild(this.element);
        }
        this.popupObj = new Popup(this.element, {
            height: this.height,
            width: this.width,
            zIndex: this.zIndex,
            relateTo: this.target,
            actionOnScroll: 'none',
            open: () => {
                this.focusContent();
                this.trigger('open');
            },
            close: (event: Event) => {
                this.unBindEvent(this.element);
                if (this.isModal) {
                    this.dlgContainer.style.display = 'none';
                }
                this.trigger('close', this.closedFrom);
                this.closedFrom = {};
                if (!isNullOrUndefined(this.storeActiveElement)) {
                    this.storeActiveElement.focus();
                }
            }
        });
        this.positionChange();
        this.setEnableRTL();
        addClass([this.element], DLG_HIDE);
        if (this.isModal) {
            this.setOverlayZindex();
        }
        if (this.visible) {
            this.show();
        } else {
            if (this.isModal) {
                this.dlgOverlay.style.display = 'none';
            }
        }
    }

    private setOverlayZindex(): void {
        let zIndex: number = parseInt(this.element.style.zIndex, 10) ? parseInt(this.element.style.zIndex, 10) : this.zIndex;
        this.dlgOverlay.style.zIndex = (zIndex - 1).toString();
        this.dlgContainer.style.zIndex = zIndex.toString();
    }

    private positionChange(): void {
        if (!this.isModal) {
            this.popupObj.setProperties({
                position: {
                    X: this.position.X, Y: this.position.Y
                }
            });
        } else {
            this.dlgContainer.classList.add('e-dlg-' + this.position.X + '-' + this.position.Y);
        }
    }

    private setAllowDragging(): void {
        let handleContent: string = '.' + DLG_HEADER_CONTENT;
        this.dragObj = new Draggable(this.element, {
            clone: false,
            handle: handleContent,
            dragStart: (event: Object) => {
                this.trigger('dragStart', event);
            },
            dragStop: (event: Object) => {
                this.trigger('dragStop', event);
            },
            drag: (event: Object) => {
                this.trigger('drag', event);
            }
        });
        if (!isNullOrUndefined(this.targetEle)) {
            this.dragObj.dragArea = this.targetEle;
        }
    }

    private setButton(): void {
        this.buttonContent = [];
        this.btnObj = [];
        let primaryBtnFlag: boolean = true;
        for (let i: number = 0; i < this.buttons.length; i++) {
            let btn: HTMLElement = createElement('button', { attrs: {type: 'button' }});
            this.buttonContent.push(btn.outerHTML);
        }
        this.setFooterTemplate();
        for (let i: number = 0; i < this.buttons.length; i++) {
            this.btnObj[i] = new Button(this.buttons[i].buttonModel);
            if (typeof (this.buttons[i].click) === 'function') {
                EventHandler.add(this.ftrTemplateContent.children[i], 'click', this.buttons[i].click, this);
            }
            this.btnObj[i].appendTo(this.ftrTemplateContent.children[i] as HTMLElement);
            if ( !this.btnObj[i].isPrimary ) {
                this.btnObj[i].element.classList.add('e-flat');
            }
            this.primaryButtonEle = this.element.getElementsByClassName('e-primary')[0] as HTMLElement;
        }
    }

    private setContent(): void {
        attributes(this.element, { 'aria-describedby': this.element.id + '_dialog-content' });
        this.contentEle = createElement('div', { className: DLG_CONTENT, id: this.element.id + '_dialog-content' });
        typeof (this.content) === 'string' ? this.contentEle.innerHTML = this.content : this.contentEle.appendChild(this.content);
        !isNullOrUndefined(this.headerContent) ? this.element.insertBefore(this.contentEle, this.element.children[1]) :
            this.element.insertBefore(this.contentEle, this.element.children[0]);
        if (this.height === 'auto') {
            this.setMaxHeight();
        }
    }

    private setMaxHeight(): void {
        let display: string = this.element.style.display;
        this.element.style.display = 'none';
        this.element.style.maxHeight = (!isNullOrUndefined(this.target)) ?
            (this.targetEle.offsetHeight - 20) + 'px' : (window.innerHeight - 20) + 'px';
        this.element.style.display = display;
    }

    private setEnableRTL(): void {
        this.enableRtl ? addClass([this.element], RTL) : removeClass([this.element], RTL);
    }

    private setTargetContent(): void {
        let isContent: boolean = this.element.innerHTML.replace(/\s/g, '') !== '';
        if (this.element.children.length > 0 || isContent) {
            let contentDiv: Node = document.createDocumentFragment();
            while ( this.element.childNodes.length !== 0 ) {
                contentDiv.appendChild(this.element.childNodes[0]);
            }
            this.setProperties({ content: contentDiv }, true);
        }
    }

    private setHeader(): void {
        this.headerEle = createElement('div', { id: this.element.id + '_title', className: DLG_HEADER, innerHTML: this.header });
        attributes(this.element, { 'aria-labelledby': this.element.id + '_title' });
        this.createHeaderContent();
        this.headerContent.appendChild(this.headerEle);
        this.element.insertBefore(this.headerContent, this.element.children[0]);
    }

    private setFooterTemplate(): void {
        this.ftrTemplateContent = createElement('div', {
            className: DLG_FOOTER_CONTENT,
            innerHTML: (this.footerTemplate !== '' ? this.footerTemplate : this.buttonContent.join(''))
        });
        this.element.appendChild(this.ftrTemplateContent);
    }

    private createHeaderContent(): void {
        if (isNullOrUndefined(this.headerContent)) {
            this.headerContent = createElement('div', { className: DLG_HEADER_CONTENT });
        }
    }

    private renderCloseIcon(): void {
        this.closeIcon = createElement('button', { className: DLG_CLOSE_ICON_BTN , attrs: {type: 'button' }});
        this.closeIconBtnObj = new Button({ cssClass: 'e-flat', iconCss: DLG_CLOSE_ICON + ' ' + ICON });
        this.closeIconTitle();
        if (!isNullOrUndefined(this.headerContent)) {
            prepend([this.closeIcon], this.headerContent);
        } else {
            this.createHeaderContent();
            prepend([this.closeIcon], this.headerContent);
            this.element.insertBefore(this.headerContent, this.element.children[0]);
        }
        this.closeIconBtnObj.appendTo(this.closeIcon);
    }

    private closeIconTitle(): void {
            this.l10n.setLocale(this.locale);
            let closeIconTitle: string = this.l10n.getConstant('close');
            this.closeIcon.setAttribute('title', closeIconTitle);
    }

    private setCSSClass(oldCSSClass?: string): void {
        if (this.cssClass) {
            addClass([this.element], this.cssClass.split(' '));
        }
        if (oldCSSClass) {
            removeClass([this.element], oldCSSClass.split(' '));
        }
    }

    private setIsModal(): void {
        this.dlgContainer = createElement('div', { className: DLG_CONTAINER });
        this.element.parentNode.insertBefore(this.dlgContainer, this.element);
        this.dlgContainer.appendChild(this.element);
        addClass([this.element], MODAL_DLG);
        this.dlgOverlay = createElement('div', { className: DLG_OVERLAY });
        this.dlgOverlay.style.zIndex = (this.zIndex - 1).toString();
        this.dlgContainer.appendChild(this.dlgOverlay);
    }

    private getValidFocusNode(items: HTMLElement[]): HTMLElement {
        let node: HTMLElement;
        for (let u: number = 0; u < items.length; u++) {
            node = <HTMLElement>items[u];
            if ((node.clientHeight > 0 || (node.tagName.toLowerCase() === 'a' && node.hasAttribute('href'))) && node.tabIndex > -1 &&
                !(node as HTMLInputElement).disabled && !this.disableElement(node, '[disabled],[aria-disabled="true"],[type="hidden"]')) {
                return node;
            }
        }
        return node;
    }

    private focusableElements(content: HTMLElement): HTMLElement {
        if (!isNullOrUndefined(content)) {
            let value: string = 'input,select,textarea,button,a,[contenteditable="true"],[tabindex]';
            let items: HTMLElement[] = <HTMLElement[] & NodeListOf<Element>>content.querySelectorAll(value);
            return this.getValidFocusNode(items);
        }
        return null;
    }

    private getAutoFocusNode(container: HTMLElement): HTMLElement {
        let node: HTMLElement = <HTMLElement>container.querySelector('.' + DLG_CLOSE_ICON_BTN);
        let value: string = '[autofocus]';
        let items: HTMLElement[] = <HTMLElement[] & NodeListOf<Element>>container.querySelectorAll(value);
        let validNode: HTMLElement = this.getValidFocusNode(items);
        if (!isNullOrUndefined(validNode)) {
            node = validNode;
        } else {
            validNode = this.focusableElements(this.contentEle);
            if (!isNullOrUndefined(validNode)) {
                return node = validNode;
            } else if (!isNullOrUndefined(this.primaryButtonEle)) {
                return (this.element.querySelector('.' + DLG_PRIMARY_BUTTON) as HTMLElement);
            }
        }
        return node;
    }

    private disableElement(element: HTMLElement, t: string): HTMLElement {
        let elementMatch: Function = element ? element.matches || element.webkitMatchesSelector || element.msMatchesSelector : null;
        if (elementMatch) {
            for (; element; element = <HTMLElement>element.parentNode) {
                if (element instanceof Element && elementMatch.call(element, t)) { return element; }
            }
        }
        return null;
    }

    private focusContent(): void {
        let element: HTMLElement = this.getAutoFocusNode(this.element);
        let node: HTMLElement = !isNullOrUndefined(element) ? element : this.element;
        node.focus();
        this.bindEvent(this.element);
    }

    private bindEvent(element: HTMLElement): void {
        EventHandler.add(element, 'keydown', this.keyDown, this);
    }

    private unBindEvent(element: HTMLElement): void {
        EventHandler.remove(element, 'keydown', this.keyDown);
    }

    /**
     * Module required function    
     * @private 
     */
    protected getModuleName(): string {
        return 'dialog';
    }
    /**
     * Called internally if any of the property value changed
     * @private
     */
    public onPropertyChanged(newProp: DialogModel, oldProp: DialogModel): void {
        for (let prop of Object.keys(newProp)) {
            switch (prop) {
                case 'content':
                    if (!isNullOrUndefined(this.content) && this.content !== '') {
                        if (!isNullOrUndefined(this.contentEle) && this.contentEle.getAttribute('role') !== 'dialog') {
                            this.contentEle.innerHTML = '';
                            typeof (this.content) === 'string' ?
                                this.contentEle.innerHTML = this.content : this.contentEle.appendChild(this.content);
                            this.setMaxHeight();
                        } else {
                            this.setContent();
                        }
                    } else if (!isNullOrUndefined(this.contentEle)) {
                            this.element.removeChild(this.contentEle);
                    }
                    break;
                case 'header':
                    if (this.header === '') {
                        detach(this.headerEle);
                    } else {
                        this.element.getElementsByClassName(DLG_HEADER).length > 0 ?
                            this.element.getElementsByClassName(DLG_HEADER)[0].innerHTML = this.header
                            : this.setHeader();
                    }
                    break;
                case 'footerTemplate':
                    this.element.getElementsByClassName(DLG_FOOTER_CONTENT).length > 0 ?
                        this.ftrTemplateContent.innerHTML = this.footerTemplate : this.setFooterTemplate();
                    break;
                case 'showCloseIcon':
                    if (this.element.getElementsByClassName(DLG_CLOSE_ICON).length > 0) {
                        if (!this.showCloseIcon && this.header === '') {
                            detach(this.headerContent);
                        } else if (!this.showCloseIcon) { detach(this.closeIcon); }
                    } else { this.renderCloseIcon(); this.wireEvents(); }
                    break;
                case 'locale':
                    if (this.showCloseIcon) {
                        this.closeIconTitle();
                    } break;
                case 'visible':
                    this.visible ? this.show() : this.hide(); break;
                case 'isModal':
                    this.element.setAttribute('aria-modal', this.isModal ? 'true' : 'false');
                    if (this.isModal) {
                        this.setIsModal(); this.wireEvents();
                        if (!isNullOrUndefined(this.targetEle)) {
                            this.isModal ? this.targetEle.appendChild(this.dlgContainer) : this.targetEle.appendChild(this.element);
                        }
                    } else {
                        removeClass([this.element], MODAL_DLG);
                        removeClass([document.body], SCROLL_DISABLED);
                        detach(this.dlgOverlay);
                        while (this.dlgContainer.firstChild) {
                            this.dlgContainer.parentElement.insertBefore(this.dlgContainer.firstChild, this.dlgContainer);
                        }
                        this.dlgContainer.parentElement.removeChild(this.dlgContainer);
                    } break;
                case 'height':
                    setStyleAttribute(this.element, { 'height': formatUnit(newProp.height) }); break;
                case 'width':
                    setStyleAttribute(this.element, { 'width': formatUnit(newProp.width) }); break;
                case 'zIndex':
                    this.popupObj.zIndex = this.zIndex;
                    if (this.isModal) { this.setOverlayZindex(); }
                    break;
                case 'cssClass':
                    this.setCSSClass(oldProp.cssClass); break;
                case 'animationSettings':
                    this.show(); break;
                case 'buttons':
                    if (!isNullOrUndefined(this.buttons[0].buttonModel) && this.footerTemplate === '') {
                        if (!isNullOrUndefined(this.ftrTemplateContent)) {
                            detach(this.ftrTemplateContent);
                        }
                        this.setButton();
                    } break;
                case 'allowDragging':
                    if (this.allowDragging && (!this.isModal) && (!isNullOrUndefined(this.headerContent))) {
                        this.setAllowDragging();
                    } else {
                        this.dragObj.destroy();
                    } break;
                case 'target':
                    this.popupObj.relateTo = newProp.target;
                    break;
                case 'position':
                    if (oldProp.position.X === this.position.X && oldProp.position.Y === this.position.Y) { break; }
                    if (this.isModal) {
                        this.dlgContainer.classList.remove('e-dlg-' + oldProp.position.X + '-' + oldProp.position.Y);
                        this.dlgContainer.classList.add('e-dlg-' + this.position.X + '-' + this.position.Y);
                    } else {
                        this.popupObj.position.X = this.position.X; this.popupObj.position.Y = this.position.Y; break;
                    }
                    break;
                case 'enableRtl':
                    this.setEnableRTL(); break;
            }
        }
    }
    /**
     * Get the properties to be maintained in the persisted state.
     * @private
     */
    protected getPersistData(): string {
        return this.addOnPersist([]);
    }
    /**
     * To destroy the widget
     * @method destroy
     * @return {void}
     * @private
     * @memberof dialog
     */
    public destroy(): void {
        if (this.element.classList.contains(ROOT)) {
            this.unWireEvents();
            super.destroy();
            let classArray: string[] = [
                ROOT, RTL, MODAL_DLG
            ];
            removeClass([this.element, this.element], classArray);
            if (this.popupObj.element.classList.contains(POPUP_ROOT)) {
                this.popupObj.destroy();
            }
            if (!isNullOrUndefined(this.btnObj)) {
                for (let i: number; i < this.btnObj.length; i++) {
                    this.btnObj[i].destroy();
                }
            }
            if (this.isModal) {
                detach(this.dlgOverlay);
                this.dlgContainer.parentNode.insertBefore(this.element, this.dlgContainer);
                detach(this.dlgContainer);
            }
            this.element.innerHTML = '';
            while (this.element.attributes.length > 0) {
                this.element.removeAttribute(this.element.attributes[0].name);
            }
            for (let k: number = 0; k < this.clonedEle.attributes.length; k++) {
                this.element.setAttribute(this.clonedEle.attributes[k].name, this.clonedEle.attributes[k].value);
            }
        }
    }

    /**
     * Binding event to the element while widget creation
     * @hidden
     */
    private wireEvents(): void {
        if (this.showCloseIcon) {
            EventHandler.add(
                this.closeIcon, 'click', this.closeIconClickEventHandler, this);
        }
        if (this.isModal) {
            EventHandler.add(this.dlgOverlay, 'click', this.dlgOverlayClickEventHandler, this);
        }
    }
    /**
     * Unbinding event to the element while widget destroy
     * @hidden
     */
    private unWireEvents(): void {
        if (this.showCloseIcon) {
            EventHandler.remove(this.closeIcon, 'click', this.closeIconClickEventHandler);
        }
        if (this.isModal) {
            EventHandler.remove(this.dlgOverlay, 'click', this.dlgOverlayClickEventHandler);
        }

        if (!isNullOrUndefined(this.buttons[0].buttonModel)) {
            for (let i: number = 0; i < this.buttons.length; i++) {
                if (typeof (this.buttons[i].click) === 'function') {
                    EventHandler.remove(this.ftrTemplateContent.children[i], 'click', this.buttons[i].click);
                }
            }
        }
    }
    /**
     * Specifies dialog offset x and y position changed dynamically or
     * change the header,footer height or width dynamically, reposition the dialog as per the new changes.
     * @return {void}
     */
    public refreshPosition(): void {
        this.popupObj.refreshPosition();
    }
    /**
     * To show the Dialog element on screen.
     * To enable the fullScreen Dialog pass the parameter to 'true'.
     * @param { boolean } isFullScreen - Enable the fullScreen Dialog.
     * @return {void}
     */
    public show(isFullScreen?: boolean): void {
        if (!this.element.classList.contains(DLG_SHOW) || (!isNullOrUndefined(isFullScreen))) {
            if (!isNullOrUndefined(isFullScreen)) {
                this.fullScreen(isFullScreen);
            }
            let eventArgs: BeforeOpenEventArgs = {
                cancel: false,
                container: this.isModal ? this.dlgContainer : this.element
            };
            this.trigger('beforeOpen', eventArgs);
            if (eventArgs.cancel) { return; }
            this.storeActiveElement = <HTMLElement>document.activeElement;
            this.element.tabIndex = -1;
            if (this.isModal && (!isNullOrUndefined(this.dlgOverlay))) {
                this.dlgOverlay.style.display = 'block';
                this.dlgContainer.style.display = 'flex';
                if (!isNullOrUndefined(this.targetEle)) {
                    if (this.targetEle === document.body) {
                        this.dlgContainer.style.position = 'fixed';
                    } else {
                        this.dlgContainer.style.position = 'absolute';
                    }
                    this.dlgOverlay.style.position = 'absolute';
                    this.element.style.position = 'relative';
                    addClass([this.targetEle], SCROLL_DISABLED);
                } else {
                    addClass([document.body], SCROLL_DISABLED);
                }
            }
            let openAnimation: Object = {
                name: this.animationSettings.effect + 'In',
                duration: this.animationSettings.duration,
                delay: this.animationSettings.delay
            };
            this.animationSettings.effect === 'None' ? this.popupObj.show() : this.popupObj.show(openAnimation);
            this.dialogOpen = true;
            this.visible = true;
        }
    }
    /**
     * To hide the Dialog element on screen.
     * @return {void}
     */
    public hide(): void {
        let eventArgs: BeforeCloseEventArgs = {
            cancel: false,
            container: this.isModal ? this.dlgContainer : this.element
        };
        this.trigger('beforeClose', eventArgs);
        if (eventArgs.cancel) { return; }
        if (this.isModal) {
            this.dlgOverlay.style.display = 'none';
            !isNullOrUndefined(this.targetEle) ? removeClass([this.targetEle], SCROLL_DISABLED) :
                removeClass([document.body], SCROLL_DISABLED);
        }
        let closeAnimation: Object = {
            name: this.animationSettings.effect + 'Out',
            duration: this.animationSettings.duration,
            delay: this.animationSettings.delay
        };
        this.animationSettings.effect === 'None' ? this.popupObj.hide() : this.popupObj.hide(closeAnimation);
        this.dialogOpen = false;
        this.visible = false;
    }
    /**
     * Specifies to view the Full screen Dialog.
     * @private
     */
    private fullScreen(args: boolean): boolean {
        let top: number = this.element.offsetTop;
        let left: number = this.element.offsetLeft;
        if (args) {
            addClass([this.element], FULLSCREEN);
            let display: string = this.element.style.display;
            this.element.style.display = 'none';
            this.element.style.maxHeight = (!isNullOrUndefined(this.target)) ?
                (this.targetEle.offsetHeight) + 'px' : (window.innerHeight) + 'px';
            this.element.style.display = display;
            addClass([document.body], SCROLL_DISABLED);
            if (this.allowDragging && !isNullOrUndefined(this.dragObj)) {
                this.dragObj.destroy();
            }
        } else {
            removeClass([this.element], FULLSCREEN);
            removeClass([document.body], SCROLL_DISABLED);
            if (this.allowDragging && (!this.isModal) && (!isNullOrUndefined(this.headerContent))) {
                this.setAllowDragging();
            }
        }
        return args;
    }
}