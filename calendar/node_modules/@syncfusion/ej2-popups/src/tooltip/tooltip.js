var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define(["require", "exports", "@syncfusion/ej2-base", "@syncfusion/ej2-base", "@syncfusion/ej2-base", "@syncfusion/ej2-base", "@syncfusion/ej2-base", "../popup/popup", "../common/position", "../common/collision"], function (require, exports, ej2_base_1, ej2_base_2, ej2_base_3, ej2_base_4, ej2_base_5, popup_1, position_1, collision_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TOUCHEND_HIDE_DELAY = 1500;
    var TAPHOLD_THRESHOLD = 500;
    var SHOW_POINTER_TIP_GAP = 0;
    var HIDE_POINTER_TIP_GAP = 8;
    var MOUSE_TRAIL_GAP = 2;
    var POINTER_ADJUST = 2;
    var ROOT = 'e-tooltip';
    var RTL = 'e-rtl';
    var DEVICE = 'e-bigger';
    var ICON = 'e-icons';
    var CLOSE = 'e-tooltip-close';
    var TOOLTIP_WRAP = 'e-tooltip-wrap';
    var CONTENT = 'e-tip-content';
    var ARROW_TIP = 'e-arrow-tip';
    var ARROW_TIP_OUTER = 'e-arrow-tip-outer';
    var ARROW_TIP_INNER = 'e-arrow-tip-inner';
    var TIP_BOTTOM = 'e-tip-bottom';
    var TIP_TOP = 'e-tip-top';
    var TIP_LEFT = 'e-tip-left';
    var TIP_RIGHT = 'e-tip-right';
    var POPUP_ROOT = 'e-popup';
    var POPUP_OPEN = 'e-popup-open';
    var POPUP_CLOSE = 'e-popup-close';
    var Animation = (function (_super) {
        __extends(Animation, _super);
        function Animation() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        __decorate([
            ej2_base_1.Property({ effect: 'FadeIn', duration: 150, delay: 0 })
        ], Animation.prototype, "open", void 0);
        __decorate([
            ej2_base_1.Property({ effect: 'FadeOut', duration: 150, delay: 0 })
        ], Animation.prototype, "close", void 0);
        return Animation;
    }(ej2_base_1.ChildProperty));
    exports.Animation = Animation;
    var Tooltip = (function (_super) {
        __extends(Tooltip, _super);
        function Tooltip(options, element) {
            return _super.call(this, options, element) || this;
        }
        Tooltip.prototype.initialize = function () {
            this.formatPosition();
            ej2_base_4.addClass([this.element], ROOT);
        };
        Tooltip.prototype.formatPosition = function () {
            if (this.position.indexOf('Top') === 0 || this.position.indexOf('Bottom') === 0) {
                _a = this.position.split(/(?=[A-Z])/), this.tooltipPositionY = _a[0], this.tooltipPositionX = _a[1];
            }
            else {
                _b = this.position.split(/(?=[A-Z])/), this.tooltipPositionX = _b[0], this.tooltipPositionY = _b[1];
            }
            var _a, _b;
        };
        Tooltip.prototype.renderArrow = function () {
            this.setTipClass(this.position);
            var tip = ej2_base_4.createElement('div', { className: ARROW_TIP + ' ' + this.tipClass });
            tip.appendChild(ej2_base_4.createElement('div', { className: ARROW_TIP_OUTER + ' ' + this.tipClass }));
            tip.appendChild(ej2_base_4.createElement('div', { className: ARROW_TIP_INNER + ' ' + this.tipClass }));
            this.tooltipEle.appendChild(tip);
        };
        Tooltip.prototype.setTipClass = function (position) {
            if (position.indexOf('Right') === 0) {
                this.tipClass = TIP_LEFT;
            }
            else if (position.indexOf('Bottom') === 0) {
                this.tipClass = TIP_TOP;
            }
            else if (position.indexOf('Left') === 0) {
                this.tipClass = TIP_RIGHT;
            }
            else {
                this.tipClass = TIP_BOTTOM;
            }
        };
        Tooltip.prototype.renderPopup = function (target) {
            var elePos = this.mouseTrail ? { top: 0, left: 0 } : this.getTooltipPosition(target);
            this.popupObj = new popup_1.Popup(this.tooltipEle, {
                height: this.height,
                width: this.width,
                position: {
                    X: elePos.left,
                    Y: elePos.top
                },
                enableRtl: this.enableRtl,
                open: this.openPopupHandler.bind(this),
                close: this.closePopupHandler.bind(this)
            });
        };
        Tooltip.prototype.getTooltipPosition = function (target) {
            var pos = position_1.calculatePosition(target, this.tooltipPositionX, this.tooltipPositionY);
            var offsetPos = this.calculateTooltipOffset(this.position);
            var elePos = this.collisionFlipFit(target, pos.left + offsetPos.left, pos.top + offsetPos.top);
            return elePos;
        };
        Tooltip.prototype.reposition = function (target) {
            var elePos = this.getTooltipPosition(target);
            this.popupObj.position = { X: elePos.left, Y: elePos.top };
            this.popupObj.dataBind();
        };
        Tooltip.prototype.openPopupHandler = function () {
            this.trigger('afterOpen', this.tooltipEventArgs);
        };
        Tooltip.prototype.closePopupHandler = function () {
            this.clear();
            this.trigger('afterClose', this.tooltipEventArgs);
        };
        Tooltip.prototype.calculateTooltipOffset = function (position) {
            var pos = { top: 0, left: 0 };
            var tooltipEleWidth = this.tooltipEle.offsetWidth;
            var tooltipEleHeight = this.tooltipEle.offsetHeight;
            var arrowEle = this.tooltipEle.querySelector('.' + ARROW_TIP);
            var tipWidth = arrowEle ? arrowEle.offsetWidth : 0;
            var tipHeight = arrowEle ? arrowEle.offsetHeight : 0;
            var tipAdjust = (this.showTipPointer ? SHOW_POINTER_TIP_GAP : HIDE_POINTER_TIP_GAP);
            var tipHeightAdjust = (tipHeight / 2) + POINTER_ADJUST + (this.tooltipEle.offsetHeight - this.tooltipEle.clientHeight);
            var tipWidthAdjust = (tipWidth / 2) + POINTER_ADJUST + (this.tooltipEle.offsetWidth - this.tooltipEle.clientWidth);
            if (this.mouseTrail) {
                tipAdjust += MOUSE_TRAIL_GAP;
            }
            switch (position) {
                case 'RightTop':
                    pos.left += tipWidth + tipAdjust;
                    pos.top -= tooltipEleHeight - tipHeightAdjust;
                    break;
                case 'RightCenter':
                    pos.left += tipWidth + tipAdjust;
                    pos.top -= (tooltipEleHeight / 2);
                    break;
                case 'RightBottom':
                    pos.left += tipWidth + tipAdjust;
                    pos.top -= (tipHeightAdjust);
                    break;
                case 'BottomRight':
                    pos.top += (tipHeight + tipAdjust);
                    pos.left -= (tipWidthAdjust);
                    break;
                case 'BottomCenter':
                    pos.top += (tipHeight + tipAdjust);
                    pos.left -= (tooltipEleWidth / 2);
                    break;
                case 'BottomLeft':
                    pos.top += (tipHeight + tipAdjust);
                    pos.left -= (tooltipEleWidth - tipWidthAdjust);
                    break;
                case 'LeftBottom':
                    pos.left -= (tipWidth + tooltipEleWidth + tipAdjust);
                    pos.top -= (tipHeightAdjust);
                    break;
                case 'LeftCenter':
                    pos.left -= (tipWidth + tooltipEleWidth + tipAdjust);
                    pos.top -= (tooltipEleHeight / 2);
                    break;
                case 'LeftTop':
                    pos.left -= (tipWidth + tooltipEleWidth + tipAdjust);
                    pos.top -= (tooltipEleHeight - tipHeightAdjust);
                    break;
                case 'TopLeft':
                    pos.top -= (tooltipEleHeight + tipHeight + tipAdjust);
                    pos.left -= (tooltipEleWidth - tipWidthAdjust);
                    break;
                case 'TopRight':
                    pos.top -= (tooltipEleHeight + tipHeight + tipAdjust);
                    pos.left -= (tipWidthAdjust);
                    break;
                default:
                    pos.top -= (tooltipEleHeight + tipHeight + tipAdjust);
                    pos.left -= (tooltipEleWidth / 2);
                    break;
            }
            pos.left += this.offsetX;
            pos.top += this.offsetY;
            return pos;
        };
        Tooltip.prototype.updateTipPosition = function (position) {
            var selEle = this.tooltipEle.querySelectorAll('.' + ARROW_TIP + ',.' + ARROW_TIP_OUTER + ',.' + ARROW_TIP_INNER);
            var removeList = [TIP_BOTTOM, TIP_TOP, TIP_LEFT, TIP_RIGHT];
            ej2_base_4.removeClass(selEle, removeList);
            this.setTipClass(position);
            ej2_base_4.addClass(selEle, this.tipClass);
        };
        Tooltip.prototype.adjustArrow = function (target, position, tooltipPositionX, tooltipPositionY) {
            if (this.showTipPointer === false) {
                return;
            }
            this.updateTipPosition(position);
            var leftValue;
            var topValue;
            var tooltipWidth = this.tooltipEle.clientWidth;
            var tooltipHeight = this.tooltipEle.clientHeight;
            var arrowEle = this.tooltipEle.querySelector('.' + ARROW_TIP);
            var arrowInnerELe = this.tooltipEle.querySelector('.' + ARROW_TIP_INNER);
            var tipWidth = arrowEle.offsetWidth;
            var tipHeight = arrowEle.offsetHeight;
            if (this.tipClass === TIP_BOTTOM || this.tipClass === TIP_TOP) {
                if (this.tipClass === TIP_BOTTOM) {
                    topValue = '99.9%';
                    arrowInnerELe.style.top = '-' + (tipHeight - 2) + 'px';
                }
                else {
                    topValue = -(tipHeight - 1) + 'px';
                    arrowInnerELe.style.top = '-' + (tipHeight - 6) + 'px';
                }
                var tipPosExclude = tooltipPositionX !== 'Center' || (tooltipWidth > target.offsetWidth) || this.mouseTrail;
                if ((tipPosExclude && tooltipPositionX === 'Left') || (!tipPosExclude && this.tipPointerPosition === 'End')) {
                    leftValue = (tooltipWidth - tipWidth - POINTER_ADJUST) + 'px';
                }
                else if ((tipPosExclude && tooltipPositionX === 'Right') || (!tipPosExclude && this.tipPointerPosition === 'Start')) {
                    leftValue = POINTER_ADJUST + 'px';
                }
                else {
                    leftValue = ((tooltipWidth / 2) - (tipWidth / 2)) + 'px';
                }
            }
            else {
                if (this.tipClass === TIP_RIGHT) {
                    leftValue = '99.9%';
                    arrowInnerELe.style.left = '-' + (tipWidth - 2) + 'px';
                }
                else {
                    leftValue = -(tipWidth - 1) + 'px';
                    arrowInnerELe.style.left = (-(tipWidth) + (tipWidth - 2)) + 'px';
                }
                var tipPosExclude = tooltipPositionY !== 'Center' || (tooltipHeight > target.offsetHeight) || this.mouseTrail;
                if ((tipPosExclude && tooltipPositionY === 'Top') || (!tipPosExclude && this.tipPointerPosition === 'End')) {
                    topValue = (tooltipHeight - tipHeight - POINTER_ADJUST) + 'px';
                }
                else if ((tipPosExclude && tooltipPositionY === 'Bottom') || (!tipPosExclude && this.tipPointerPosition === 'Start')) {
                    topValue = POINTER_ADJUST + 'px';
                }
                else {
                    topValue = ((tooltipHeight / 2) - (tipHeight / 2)) + 'px';
                }
            }
            arrowEle.style.top = topValue;
            arrowEle.style.left = leftValue;
        };
        Tooltip.prototype.renderContent = function (target) {
            var tooltipContent = this.tooltipEle.querySelector('.' + CONTENT);
            if (target && !ej2_base_3.isNullOrUndefined(target.getAttribute('title'))) {
                target.setAttribute('data-content', target.getAttribute('title'));
                target.removeAttribute('title');
            }
            if (!ej2_base_3.isNullOrUndefined(this.content)) {
                if (typeof (this.content) === 'string') {
                    tooltipContent.innerHTML = this.content;
                }
                else {
                    while (tooltipContent.firstChild) {
                        tooltipContent.removeChild(tooltipContent.firstChild);
                    }
                    tooltipContent.appendChild(this.content);
                }
            }
            else {
                if (target && !ej2_base_3.isNullOrUndefined(target.getAttribute('data-content'))) {
                    tooltipContent.innerHTML = target.getAttribute('data-content');
                }
            }
        };
        Tooltip.prototype.renderCloseIcon = function () {
            if (!this.isSticky) {
                return;
            }
            var tipClose = ej2_base_4.createElement('div', { className: ICON + ' ' + CLOSE });
            this.tooltipEle.appendChild(tipClose);
            ej2_base_2.EventHandler.add(tipClose, ej2_base_2.Browser.touchStartEvent, this.onStickyClose, this);
        };
        Tooltip.prototype.addDescribedBy = function (target, id) {
            var describedby = (target.getAttribute('aria-describedby') || '').split(/\s+/);
            if (describedby.indexOf(id) < 0) {
                describedby.push(id);
            }
            ej2_base_4.attributes(target, { 'aria-describedby': describedby.join(' ').trim(), 'data-tooltip-id': id });
        };
        Tooltip.prototype.removeDescribedBy = function (target) {
            var id = target.getAttribute('data-tooltip-id');
            var describedby = (target.getAttribute('aria-describedby') || '').split(/\s+/);
            var index = describedby.indexOf(id);
            if (index !== -1) {
                describedby.splice(index, 1);
            }
            target.removeAttribute('data-tooltip-id');
            var orgdescribedby = describedby.join(' ').trim();
            if (orgdescribedby) {
                target.setAttribute('aria-describedby', orgdescribedby);
            }
            else {
                target.removeAttribute('aria-describedby');
            }
        };
        Tooltip.prototype.tapHoldHandler = function (evt) {
            clearTimeout(this.autoCloseTimer);
            this.targetHover(evt.originalEvent);
        };
        Tooltip.prototype.touchEndHandler = function (e) {
            var _this = this;
            if (this.isSticky) {
                return;
            }
            var close = function () {
                _this.close();
            };
            this.autoCloseTimer = setTimeout(close, TOUCHEND_HIDE_DELAY);
        };
        Tooltip.prototype.targetClick = function (e) {
            var target;
            if (this.target) {
                target = ej2_base_4.closest(e.target, this.target);
            }
            else {
                target = this.element;
            }
            if (ej2_base_3.isNullOrUndefined(target)) {
                return;
            }
            if (target.getAttribute('data-tooltip-id') === null) {
                this.targetHover(e);
            }
            else if (!this.isSticky) {
                this.hideTooltip(this.animation.close, e, target);
            }
        };
        Tooltip.prototype.targetHover = function (e) {
            var target;
            if (this.target) {
                target = ej2_base_4.closest(e.target, this.target);
            }
            else {
                target = this.element;
            }
            if (ej2_base_3.isNullOrUndefined(target) || target.getAttribute('data-tooltip-id') !== null) {
                return;
            }
            var targetList = [].slice.call(document.querySelectorAll('[data-tooltip-id= ' + this.ctrlId + '_content]'));
            for (var _i = 0, targetList_1 = targetList; _i < targetList_1.length; _i++) {
                var target_1 = targetList_1[_i];
                this.restoreElement(target_1);
            }
            this.showTooltip(target, this.animation.open, e);
            this.wireMouseEvents(e, target);
        };
        Tooltip.prototype.showTooltip = function (target, showAnimation, e) {
            var _this = this;
            clearTimeout(this.showTimer);
            clearTimeout(this.hideTimer);
            this.tooltipEventArgs = e ? { type: e.type, cancel: false, target: target, event: e, element: this.tooltipEle } :
                { type: null, cancel: false, target: target, event: null, element: this.tooltipEle };
            this.trigger('beforeRender', this.tooltipEventArgs);
            if (this.tooltipEventArgs.cancel) {
                this.isHidden = true;
                this.clear();
                return;
            }
            this.isHidden = false;
            if (ej2_base_3.isNullOrUndefined(this.tooltipEle)) {
                this.ctrlId = this.element.getAttribute('id') ? ej2_base_3.getUniqueID(this.element.getAttribute('id')) : ej2_base_3.getUniqueID('tooltip');
                this.tooltipEle = ej2_base_4.createElement('div', {
                    className: TOOLTIP_WRAP + ' ' + POPUP_ROOT, attrs: {
                        role: 'tooltip', 'aria-hidden': 'false', 'id': this.ctrlId + '_content'
                    }, styles: 'width:' + ej2_base_3.formatUnit(this.width) + ';height:' + ej2_base_3.formatUnit(this.height) + ';position:absolute;'
                });
                if (this.cssClass) {
                    ej2_base_4.addClass([this.tooltipEle], this.cssClass.split(' '));
                }
                if (ej2_base_2.Browser.isDevice) {
                    ej2_base_4.addClass([this.tooltipEle], DEVICE);
                }
                if (this.width !== 'auto') {
                    this.tooltipEle.style.maxWidth = ej2_base_3.formatUnit(this.width);
                }
                this.tooltipEle.appendChild(ej2_base_4.createElement('div', { className: CONTENT }));
                document.body.appendChild(this.tooltipEle);
                this.addDescribedBy(target, this.ctrlId + '_content');
                this.renderContent(target);
                ej2_base_4.addClass([this.tooltipEle], POPUP_OPEN);
                if (this.showTipPointer) {
                    this.renderArrow();
                }
                this.renderCloseIcon();
                this.renderPopup(target);
            }
            else {
                this.adjustArrow(target, this.position, this.tooltipPositionX, this.tooltipPositionY);
                this.addDescribedBy(target, this.ctrlId + '_content');
                this.renderContent(target);
                ej2_base_2.Animation.stop(this.tooltipEle);
                this.reposition(target);
            }
            ej2_base_4.removeClass([this.tooltipEle], POPUP_OPEN);
            ej2_base_4.addClass([this.tooltipEle], POPUP_CLOSE);
            this.tooltipEventArgs = e ? { type: e.type, cancel: false, target: target, event: e, element: this.tooltipEle } :
                { type: null, cancel: false, target: target, event: null, element: this.tooltipEle };
            this.trigger('beforeOpen', this.tooltipEventArgs);
            if (this.tooltipEventArgs.cancel) {
                this.isHidden = true;
                this.clear();
                return;
            }
            var openAnimation = {
                name: showAnimation.effect, duration: showAnimation.duration, delay: showAnimation.delay, timingFunction: 'easeOut'
            };
            if (showAnimation.effect === 'None') {
                openAnimation = undefined;
            }
            if (this.openDelay > 0) {
                var show = function () {
                    if (_this.popupObj) {
                        _this.popupObj.show(openAnimation);
                    }
                };
                this.showTimer = setTimeout(show, this.openDelay);
            }
            else {
                this.popupObj.show(openAnimation);
            }
        };
        Tooltip.prototype.checkCollision = function (target, x, y) {
            var elePos = {
                left: x, top: y, position: this.position,
                horizontal: this.tooltipPositionX, vertical: this.tooltipPositionY
            };
            var affectedPos = collision_1.isCollide(this.tooltipEle, (this.target ? this.element : null), x, y);
            if (affectedPos.length > 0) {
                elePos.horizontal = affectedPos.indexOf('left') >= 0 ? 'Right' : affectedPos.indexOf('right') >= 0 ? 'Left' :
                    this.tooltipPositionX;
                elePos.vertical = affectedPos.indexOf('top') >= 0 ? 'Bottom' : affectedPos.indexOf('bottom') >= 0 ? 'Top' :
                    this.tooltipPositionY;
            }
            return elePos;
        };
        Tooltip.prototype.collisionFlipFit = function (target, x, y) {
            var elePos = this.checkCollision(target, x, y);
            var newpos = elePos.position;
            if (this.tooltipPositionY !== elePos.vertical) {
                newpos = ((this.position.indexOf('Bottom') === 0 || this.position.indexOf('Top') === 0) ?
                    elePos.vertical + this.tooltipPositionX : this.tooltipPositionX + elePos.vertical);
            }
            if (this.tooltipPositionX !== elePos.horizontal) {
                if (newpos.indexOf('Left') === 0) {
                    elePos.vertical = (newpos === 'LeftTop' || newpos === 'LeftCenter') ? 'Top' : 'Bottom';
                    newpos = (elePos.vertical + 'Left');
                }
                if (newpos.indexOf('Right') === 0) {
                    elePos.vertical = (newpos === 'RightTop' || newpos === 'RightCenter') ? 'Top' : 'Bottom';
                    newpos = (elePos.vertical + 'Right');
                }
                elePos.horizontal = this.tooltipPositionX;
            }
            this.tooltipEventArgs = {
                type: null, cancel: false, target: target, event: null,
                element: this.tooltipEle, collidedPosition: newpos
            };
            this.trigger('beforeCollision', this.tooltipEventArgs);
            if (elePos.position !== newpos) {
                var pos = position_1.calculatePosition(target, this.tooltipPositionX, elePos.vertical);
                this.adjustArrow(target, newpos, elePos.horizontal, elePos.vertical);
                var offsetPos = this.calculateTooltipOffset(newpos);
                elePos.position = newpos;
                elePos.left = pos.left + offsetPos.left;
                elePos.top = pos.top + offsetPos.top;
            }
            else {
                this.adjustArrow(target, newpos, elePos.horizontal, elePos.vertical);
            }
            var eleOffset = { left: elePos.left, top: elePos.top };
            var left = collision_1.fit(this.tooltipEle, (this.target ? this.element : null), { X: true, Y: false }, eleOffset).left;
            if (this.showTipPointer && (newpos.indexOf('Bottom') === 0 || newpos.indexOf('Top') === 0)) {
                var arrowEle = this.tooltipEle.querySelector('.' + ARROW_TIP);
                var arrowleft = parseInt(arrowEle.style.left, 10) - (left - elePos.left);
                if (arrowleft < 0) {
                    arrowleft = 0;
                }
                else if ((arrowleft + arrowEle.offsetWidth) > this.tooltipEle.clientWidth) {
                    arrowleft = this.tooltipEle.clientWidth - arrowEle.offsetWidth;
                }
                arrowEle.style.left = arrowleft.toString() + 'px';
            }
            eleOffset.left = left;
            return eleOffset;
        };
        Tooltip.prototype.hideTooltip = function (hideAnimation, e, targetElement) {
            var _this = this;
            var target;
            if (e) {
                target = this.target ? (targetElement || e.target) : this.element;
                this.tooltipEventArgs = {
                    type: e.type, cancel: false, target: target, event: e, element: this.tooltipEle
                };
            }
            else {
                target = document.querySelector('[data-tooltip-id= ' + this.ctrlId + '_content]');
                this.tooltipEventArgs = {
                    type: null, cancel: false, target: target, event: null, element: this.tooltipEle
                };
            }
            if (ej2_base_3.isNullOrUndefined(target)) {
                return;
            }
            this.trigger('beforeClose', this.tooltipEventArgs);
            if (!this.tooltipEventArgs.cancel) {
                this.restoreElement(target);
                this.isHidden = true;
                var closeAnimation_1 = {
                    name: hideAnimation.effect, duration: hideAnimation.duration, delay: hideAnimation.delay, timingFunction: 'easeIn'
                };
                if (hideAnimation.effect === 'None') {
                    closeAnimation_1 = undefined;
                }
                if (this.closeDelay > 0) {
                    var hide = function () {
                        if (_this.popupObj) {
                            _this.popupObj.hide(closeAnimation_1);
                        }
                    };
                    this.hideTimer = setTimeout(hide, this.closeDelay);
                }
                else {
                    this.popupObj.hide(closeAnimation_1);
                }
            }
            else {
                this.isHidden = false;
            }
        };
        Tooltip.prototype.restoreElement = function (target) {
            this.unwireMouseEvents(target);
            if (!ej2_base_3.isNullOrUndefined(target.getAttribute('data-content'))) {
                target.setAttribute('title', target.getAttribute('data-content'));
                target.removeAttribute('data-content');
            }
            this.removeDescribedBy(target);
        };
        Tooltip.prototype.clear = function () {
            if (this.tooltipEle) {
                ej2_base_4.removeClass([this.tooltipEle], POPUP_CLOSE);
                ej2_base_4.addClass([this.tooltipEle], POPUP_OPEN);
            }
            if (this.isHidden) {
                if (this.popupObj) {
                    this.popupObj.destroy();
                }
                if (this.tooltipEle) {
                    ej2_base_4.remove(this.tooltipEle);
                }
                this.tooltipEle = null;
                this.popupObj = null;
            }
        };
        Tooltip.prototype.onMouseOut = function (e) {
            this.hideTooltip(this.animation.close, e);
        };
        Tooltip.prototype.onStickyClose = function (e) {
            this.close();
        };
        Tooltip.prototype.onMouseMove = function (event) {
            var eventPageX = 0;
            var eventPageY = 0;
            if (event.type.indexOf('touch') > -1) {
                event.preventDefault();
                eventPageX = event.touches[0].pageX;
                eventPageY = event.touches[0].pageY;
            }
            else {
                eventPageX = event.pageX;
                eventPageY = event.pageY;
            }
            ej2_base_2.Animation.stop(this.tooltipEle);
            ej2_base_4.removeClass([this.tooltipEle], POPUP_CLOSE);
            ej2_base_4.addClass([this.tooltipEle], POPUP_OPEN);
            this.adjustArrow(event.target, this.position, this.tooltipPositionX, this.tooltipPositionY);
            var pos = this.calculateTooltipOffset(this.position);
            var x = eventPageX + pos.left + this.offsetX;
            var y = eventPageY + pos.top + this.offsetY;
            var elePos = this.checkCollision(event.target, x, y);
            if (this.tooltipPositionX !== elePos.horizontal || this.tooltipPositionY !== elePos.vertical) {
                var newpos = (this.position.indexOf('Bottom') === 0 || this.position.indexOf('Top') === 0) ?
                    elePos.vertical + elePos.horizontal : elePos.horizontal + elePos.vertical;
                elePos.position = newpos;
                this.adjustArrow(event.target, elePos.position, elePos.horizontal, elePos.vertical);
                var colpos = this.calculateTooltipOffset(elePos.position);
                elePos.left = eventPageX + colpos.left - this.offsetX;
                elePos.top = eventPageY + colpos.top - this.offsetY;
            }
            this.tooltipEle.style.left = elePos.left + 'px';
            this.tooltipEle.style.top = elePos.top + 'px';
        };
        Tooltip.prototype.keyDown = function (event) {
            if (this.tooltipEle && event.keyCode === 27) {
                this.close();
            }
        };
        Tooltip.prototype.touchEnd = function (e) {
            if (this.tooltipEle && ej2_base_4.closest(e.target, '.' + ROOT) === null) {
                this.close();
            }
        };
        Tooltip.prototype.scrollHandler = function (e) {
            if (this.tooltipEle) {
                this.close();
            }
        };
        Tooltip.prototype.render = function () {
            this.initialize();
            this.wireEvents(this.opensOn);
        };
        Tooltip.prototype.preRender = function () {
            this.tipClass = TIP_BOTTOM;
            this.tooltipPositionX = 'Center';
            this.tooltipPositionY = 'Top';
            this.isHidden = true;
        };
        Tooltip.prototype.wireEvents = function (trigger) {
            var triggerList = this.getTriggerList(trigger);
            for (var _i = 0, triggerList_1 = triggerList; _i < triggerList_1.length; _i++) {
                var opensOn = triggerList_1[_i];
                if (opensOn === 'Custom') {
                    return;
                }
                if (opensOn === 'Focus') {
                    this.wireFocusEvents();
                }
                if (opensOn === 'Click') {
                    ej2_base_2.EventHandler.add(this.element, ej2_base_2.Browser.touchStartEvent, this.targetClick, this);
                }
                if (opensOn === 'Hover') {
                    if (ej2_base_2.Browser.isDevice) {
                        this.touchModule = new ej2_base_2.Touch(this.element, {
                            tapHoldThreshold: TAPHOLD_THRESHOLD,
                            tapHold: this.tapHoldHandler.bind(this)
                        });
                        ej2_base_2.EventHandler.add(this.element, ej2_base_2.Browser.touchEndEvent, this.touchEndHandler, this);
                    }
                    else {
                        ej2_base_2.EventHandler.add(this.element, 'mouseover', this.targetHover, this);
                    }
                }
            }
            ej2_base_2.EventHandler.add(document, 'touchend', this.touchEnd, this);
            ej2_base_2.EventHandler.add(document, 'scroll', this.scrollHandler, this);
            ej2_base_2.EventHandler.add(document, 'keydown', this.keyDown, this);
        };
        Tooltip.prototype.getTriggerList = function (trigger) {
            if (trigger === 'Auto') {
                trigger = (ej2_base_2.Browser.isDevice) ? 'Hover' : 'Hover Focus';
            }
            return trigger.split(' ');
        };
        Tooltip.prototype.wireFocusEvents = function () {
            if (!ej2_base_3.isNullOrUndefined(this.target)) {
                var targetList = [].slice.call(this.element.querySelectorAll(this.target));
                for (var _i = 0, targetList_2 = targetList; _i < targetList_2.length; _i++) {
                    var target = targetList_2[_i];
                    ej2_base_2.EventHandler.add(target, 'focus', this.targetHover, this);
                }
            }
            else {
                ej2_base_2.EventHandler.add(this.element, 'focus', this.targetHover, this);
            }
        };
        Tooltip.prototype.wireMouseEvents = function (e, target) {
            if (this.tooltipEle) {
                if (!this.isSticky) {
                    if (e.type === 'focus') {
                        ej2_base_2.EventHandler.add(target, 'blur', this.onMouseOut, this);
                    }
                    if (e.type === 'mouseover') {
                        ej2_base_2.EventHandler.add(target, 'mouseleave', this.onMouseOut, this);
                    }
                }
                if (this.mouseTrail) {
                    ej2_base_2.EventHandler.add(target, 'mousemove touchstart mouseenter', this.onMouseMove, this);
                }
            }
        };
        Tooltip.prototype.unwireEvents = function (trigger) {
            var triggerList = this.getTriggerList(trigger);
            for (var _i = 0, triggerList_2 = triggerList; _i < triggerList_2.length; _i++) {
                var opensOn = triggerList_2[_i];
                if (opensOn === 'Custom') {
                    return;
                }
                if (opensOn === 'Focus') {
                    this.unwireFocusEvents();
                }
                if (opensOn === 'Click') {
                    ej2_base_2.EventHandler.remove(this.element, ej2_base_2.Browser.touchStartEvent, this.targetClick);
                }
                if (opensOn === 'Hover') {
                    if (ej2_base_2.Browser.isDevice) {
                        if (this.touchModule) {
                            this.touchModule.destroy();
                        }
                        ej2_base_2.EventHandler.remove(this.element, ej2_base_2.Browser.touchEndEvent, this.touchEndHandler);
                    }
                    else {
                        ej2_base_2.EventHandler.remove(this.element, 'mouseover', this.targetHover);
                    }
                }
            }
            ej2_base_2.EventHandler.remove(document, 'touchend', this.touchEnd);
            ej2_base_2.EventHandler.remove(document, 'scroll', this.scrollHandler);
            ej2_base_2.EventHandler.remove(document, 'keydown', this.keyDown);
        };
        Tooltip.prototype.unwireFocusEvents = function () {
            if (!ej2_base_3.isNullOrUndefined(this.target)) {
                var targetList = [].slice.call(this.element.querySelectorAll(this.target));
                for (var _i = 0, targetList_3 = targetList; _i < targetList_3.length; _i++) {
                    var target = targetList_3[_i];
                    ej2_base_2.EventHandler.remove(target, 'focus', this.targetHover);
                }
            }
            else {
                ej2_base_2.EventHandler.remove(this.element, 'focus', this.targetHover);
            }
        };
        Tooltip.prototype.unwireMouseEvents = function (target) {
            if (!this.isSticky) {
                var triggerList = this.getTriggerList(this.opensOn);
                for (var _i = 0, triggerList_3 = triggerList; _i < triggerList_3.length; _i++) {
                    var opensOn = triggerList_3[_i];
                    if (opensOn === 'Focus') {
                        ej2_base_2.EventHandler.remove(target, 'blur', this.onMouseOut);
                    }
                    if (opensOn === 'Hover' && !ej2_base_2.Browser.isDevice) {
                        ej2_base_2.EventHandler.remove(target, 'mouseleave', this.onMouseOut);
                    }
                }
            }
            if (this.mouseTrail) {
                ej2_base_2.EventHandler.remove(target, 'mousemove touchstart mouseenter', this.onMouseMove);
            }
        };
        Tooltip.prototype.getModuleName = function () {
            return 'tooltip';
        };
        Tooltip.prototype.getPersistData = function () {
            return this.addOnPersist([]);
        };
        Tooltip.prototype.onPropertyChanged = function (newProp, oldProp) {
            for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
                var prop = _a[_i];
                switch (prop) {
                    case 'width':
                        if (this.tooltipEle) {
                            this.tooltipEle.style.width = ej2_base_3.formatUnit(newProp.width);
                        }
                        break;
                    case 'height':
                        if (this.tooltipEle) {
                            this.tooltipEle.style.height = ej2_base_3.formatUnit(newProp.height);
                        }
                        break;
                    case 'content':
                        if (this.tooltipEle) {
                            this.renderContent();
                        }
                        break;
                    case 'opensOn':
                        this.unwireEvents(oldProp.opensOn);
                        this.wireEvents(newProp.opensOn);
                        break;
                    case 'position':
                        this.formatPosition();
                        var target = document.querySelector('[data-tooltip-id= ' + this.ctrlId + '_content]');
                        if (this.tooltipEle && target) {
                            var arrowInnerELe = this.tooltipEle.querySelector('.' + ARROW_TIP_INNER);
                            arrowInnerELe.style.top = arrowInnerELe.style.left = null;
                            this.reposition(target);
                        }
                        break;
                    case 'tipPointerPosition':
                        var trgt = document.querySelector('[data-tooltip-id= ' + this.ctrlId + '_content]');
                        if (this.tooltipEle && trgt) {
                            this.reposition(trgt);
                        }
                        break;
                    case 'offsetX':
                        if (this.tooltipEle) {
                            var x = newProp.offsetX - oldProp.offsetX;
                            this.tooltipEle.style.left = (parseInt(this.tooltipEle.style.left, 10) + (x)).toString() + 'px';
                        }
                        break;
                    case 'offsetY':
                        if (this.tooltipEle) {
                            var y = newProp.offsetY - oldProp.offsetY;
                            this.tooltipEle.style.top = (parseInt(this.tooltipEle.style.top, 10) + (y)).toString() + 'px';
                        }
                        break;
                    case 'cssClass':
                        if (this.tooltipEle) {
                            if (oldProp.cssClass) {
                                ej2_base_4.removeClass([this.tooltipEle], oldProp.cssClass.split(' '));
                            }
                            if (newProp.cssClass) {
                                ej2_base_4.addClass([this.tooltipEle], newProp.cssClass.split(' '));
                            }
                        }
                        break;
                    case 'enableRtl':
                        if (this.tooltipEle) {
                            if (this.enableRtl) {
                                ej2_base_4.addClass([this.tooltipEle], RTL);
                            }
                            else {
                                ej2_base_4.removeClass([this.tooltipEle], RTL);
                            }
                        }
                        break;
                }
            }
        };
        Tooltip.prototype.open = function (element, animation) {
            if (animation === void 0) { animation = this.animation.open; }
            if (element.style.display === 'none') {
                return;
            }
            this.showTooltip(element, animation);
        };
        Tooltip.prototype.close = function (animation) {
            if (animation === void 0) { animation = this.animation.close; }
            this.hideTooltip(animation);
        };
        Tooltip.prototype.refresh = function (target) {
            if (this.tooltipEle) {
                this.renderContent(target);
            }
            if (this.popupObj && target) {
                this.reposition(target);
            }
        };
        Tooltip.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            ej2_base_4.removeClass([this.element], ROOT);
            this.unwireEvents(this.opensOn);
            if (this.popupObj) {
                this.popupObj.destroy();
            }
            if (this.tooltipEle) {
                ej2_base_4.remove(this.tooltipEle);
            }
            this.tooltipEle = null;
            this.popupObj = null;
        };
        __decorate([
            ej2_base_1.Property('auto')
        ], Tooltip.prototype, "width", void 0);
        __decorate([
            ej2_base_1.Property('auto')
        ], Tooltip.prototype, "height", void 0);
        __decorate([
            ej2_base_1.Property()
        ], Tooltip.prototype, "content", void 0);
        __decorate([
            ej2_base_1.Property()
        ], Tooltip.prototype, "target", void 0);
        __decorate([
            ej2_base_1.Property('TopCenter')
        ], Tooltip.prototype, "position", void 0);
        __decorate([
            ej2_base_1.Property(0)
        ], Tooltip.prototype, "offsetX", void 0);
        __decorate([
            ej2_base_1.Property(0)
        ], Tooltip.prototype, "offsetY", void 0);
        __decorate([
            ej2_base_1.Property(true)
        ], Tooltip.prototype, "showTipPointer", void 0);
        __decorate([
            ej2_base_1.Property('Auto')
        ], Tooltip.prototype, "tipPointerPosition", void 0);
        __decorate([
            ej2_base_1.Property('Auto')
        ], Tooltip.prototype, "opensOn", void 0);
        __decorate([
            ej2_base_1.Property(false)
        ], Tooltip.prototype, "mouseTrail", void 0);
        __decorate([
            ej2_base_1.Property(false)
        ], Tooltip.prototype, "isSticky", void 0);
        __decorate([
            ej2_base_5.Complex({}, Animation)
        ], Tooltip.prototype, "animation", void 0);
        __decorate([
            ej2_base_1.Property(0)
        ], Tooltip.prototype, "openDelay", void 0);
        __decorate([
            ej2_base_1.Property(0)
        ], Tooltip.prototype, "closeDelay", void 0);
        __decorate([
            ej2_base_1.Property()
        ], Tooltip.prototype, "cssClass", void 0);
        __decorate([
            ej2_base_1.Property(false)
        ], Tooltip.prototype, "enableRtl", void 0);
        __decorate([
            ej2_base_1.Event()
        ], Tooltip.prototype, "beforeRender", void 0);
        __decorate([
            ej2_base_1.Event()
        ], Tooltip.prototype, "beforeOpen", void 0);
        __decorate([
            ej2_base_1.Event()
        ], Tooltip.prototype, "afterOpen", void 0);
        __decorate([
            ej2_base_1.Event()
        ], Tooltip.prototype, "beforeClose", void 0);
        __decorate([
            ej2_base_1.Event()
        ], Tooltip.prototype, "afterClose", void 0);
        __decorate([
            ej2_base_1.Event()
        ], Tooltip.prototype, "beforeCollision", void 0);
        __decorate([
            ej2_base_1.Event()
        ], Tooltip.prototype, "created", void 0);
        __decorate([
            ej2_base_1.Event()
        ], Tooltip.prototype, "destroyed", void 0);
        Tooltip = __decorate([
            ej2_base_5.NotifyPropertyChanges
        ], Tooltip);
        return Tooltip;
    }(ej2_base_1.Component));
    exports.Tooltip = Tooltip;
});
